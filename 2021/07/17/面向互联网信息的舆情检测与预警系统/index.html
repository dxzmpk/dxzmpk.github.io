<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E8%A7%86%E5%8A%9B%E8%A1%A8%20(1).svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E8%A7%86%E5%8A%9B%E8%A1%A8.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dxzmpk.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="面向互联网信息的舆情检测与预警系统目录 环境搭建 配置过程 获取远程develop分支   项目组件介绍 缓存机制 定时任务   性能指标与参数调整 Redis单机性能测试 负载测试 tomcat配置更新后测试【默认带有redis缓存功能】   server测试 server测试中的问题     查询优化-分库分表 未分库分表迁移到分库分表的方法 方案1 使用ResourceDatabasePop">
<meta property="og:type" content="article">
<meta property="og:title" content="面向互联网信息的舆情检测与预警系统">
<meta property="og:url" content="https://dxzmpk.github.io/2021/07/17/%E9%9D%A2%E5%90%91%E4%BA%92%E8%81%94%E7%BD%91%E4%BF%A1%E6%81%AF%E7%9A%84%E8%88%86%E6%83%85%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%A2%84%E8%AD%A6%E7%B3%BB%E7%BB%9F/">
<meta property="og:site_name" content="dxzmpk">
<meta property="og:description" content="面向互联网信息的舆情检测与预警系统目录 环境搭建 配置过程 获取远程develop分支   项目组件介绍 缓存机制 定时任务   性能指标与参数调整 Redis单机性能测试 负载测试 tomcat配置更新后测试【默认带有redis缓存功能】   server测试 server测试中的问题     查询优化-分库分表 未分库分表迁移到分库分表的方法 方案1 使用ResourceDatabasePop">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/07/17/MjsI3cwRGJzDdhB.png">
<meta property="og:image" content="https://i.loli.net/2021/07/17/XK1AuqejIDytzMV.png">
<meta property="og:image" content="https://i.loli.net/2021/07/17/fISMtouBeV5kwgH.png">
<meta property="og:image" content="https://i.loli.net/2021/06/24/LC3iJPNO5U2xcyk.png">
<meta property="og:image" content="https://i.loli.net/2021/07/17/Da5XvPg4qc3jomN.png">
<meta property="og:image" content="https://i.loli.net/2021/07/17/dIUNEB2J4aqZSjt.png">
<meta property="og:image" content="https://i.loli.net/2021/06/23/dL54u9iBDRQt6sg.png">
<meta property="article:published_time" content="2021-07-17T04:48:56.000Z">
<meta property="article:modified_time" content="2021-07-17T05:36:57.611Z">
<meta property="article:author" content="dxzmpk">
<meta property="article:tag" content="nlp">
<meta property="article:tag" content=" cs">
<meta property="article:tag" content=" hit">
<meta property="article:tag" content=" transformers">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/07/17/MjsI3cwRGJzDdhB.png">

<link rel="canonical" href="https://dxzmpk.github.io/2021/07/17/%E9%9D%A2%E5%90%91%E4%BA%92%E8%81%94%E7%BD%91%E4%BF%A1%E6%81%AF%E7%9A%84%E8%88%86%E6%83%85%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%A2%84%E8%AD%A6%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面向互联网信息的舆情检测与预警系统 | dxzmpk</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dxzmpk</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">endless hard working</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2021/07/17/%E9%9D%A2%E5%90%91%E4%BA%92%E8%81%94%E7%BD%91%E4%BF%A1%E6%81%AF%E7%9A%84%E8%88%86%E6%83%85%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%A2%84%E8%AD%A6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dxzmpk">
      <meta itemprop="description" content="Learning in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dxzmpk">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面向互联网信息的舆情检测与预警系统
        </h1>

        <div class="post-meta">
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-17 12:48:56 / 修改时间：13:36:57" itemprop="dateCreated datePublished" datetime="2021-07-17T12:48:56+08:00">2021-07-17</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/17/%E9%9D%A2%E5%90%91%E4%BA%92%E8%81%94%E7%BD%91%E4%BF%A1%E6%81%AF%E7%9A%84%E8%88%86%E6%83%85%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%A2%84%E8%AD%A6%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/17/%E9%9D%A2%E5%90%91%E4%BA%92%E8%81%94%E7%BD%91%E4%BF%A1%E6%81%AF%E7%9A%84%E8%88%86%E6%83%85%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%A2%84%E8%AD%A6%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="面向互联网信息的舆情检测与预警系统"><a href="#面向互联网信息的舆情检测与预警系统" class="headerlink" title="面向互联网信息的舆情检测与预警系统"></a>面向互联网信息的舆情检测与预警系统</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#环境搭建">环境搭建</a><ul>
<li><a href="#配置过程">配置过程</a></li>
<li><a href="#获取远程develop分支">获取远程develop分支</a></li>
</ul>
</li>
<li><a href="#项目组件介绍">项目组件介绍</a><ul>
<li><a href="#缓存机制">缓存机制</a></li>
<li><a href="#定时任务">定时任务</a></li>
</ul>
</li>
<li><a href="#性能指标与参数调整">性能指标与参数调整</a><ul>
<li><a href="#redis单机性能测试">Redis单机性能测试</a></li>
<li><a href="#负载测试">负载测试</a><ul>
<li><a href="#tomcat配置更新后测试默认带有redis缓存功能">tomcat配置更新后测试【默认带有redis缓存功能】</a></li>
</ul>
</li>
<li><a href="#server测试">server测试</a><ul>
<li><a href="#server测试中的问题">server测试中的问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#查询优化-分库分表">查询优化-分库分表</a><ul>
<li><a href="#未分库分表迁移到分库分表的方法">未分库分表迁移到分库分表的方法</a><ul>
<li><a href="#方案1-使用resourcedatabasepopulator进行迁移"><strong>方案1 使用</strong>ResourceDatabasePopulator进行迁移</a></li>
<li><a href="#方案2-从旧库读取然后插入新库中"><strong>方案2 从旧库读取，然后插入新库中</strong></a></li>
</ul>
</li>
<li><a href="#分库分表前后接口耗时测试">分库分表前后接口耗时测试</a></li>
<li><a href="#分库分表带来的复杂性">分库分表带来的复杂性</a><ul>
<li><a href="#跨库关联查询">跨库关联查询</a></li>
<li><a href="#分布式事务">分布式事务</a></li>
<li><a href="#排序分页函数计算问题">排序、分页、函数计算问题</a></li>
<li><a href="#分布式id">分布式id</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><ul>
<li>导入项目到idea中: File-&gt;open-&gt;选中pom.xml-&gt;open as project</li>
<li>IDEA安装lombok插件</li>
<li>运行BackendApplication</li>
<li>浏览器打开<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> 查看接口</li>
</ul>
<h2 id="获取远程develop分支"><a href="#获取远程develop分支" class="headerlink" title="获取远程develop分支"></a>获取远程develop分支</h2><ol>
<li>.git中config文件fetch修改为    fetch = +refs/heads/<em>:refs/remotes/origin/</em></li>
<li>右下角刷新、选择分支<br><img src="https://i.loli.net/2021/07/17/MjsI3cwRGJzDdhB.png" alt="img.png"></li>
</ol>
<p><img src="https://i.loli.net/2021/07/17/XK1AuqejIDytzMV.png" alt="img.png"></p>
<h1 id="项目组件介绍"><a href="#项目组件介绍" class="headerlink" title="项目组件介绍"></a>项目组件介绍</h1><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><ol>
<li>返回的对象需要实现Serializable接口</li>
<li>返回的方法添加@Cacheable(cacheNames = “MESSAGE”, keyGenerator = “DEFAULT”)注解</li>
<li>默认的缓存过期时间为一小时</li>
</ol>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>定时执行某些接口<br>为了保证接口的数据被成功缓存，不能直接调用controller中的方法，而应该使用restTemplate的方式进行调用<br>定时任务采用 接口名称 + cron表达式进行设置<br>cron表达式用来规定执行的时间，具体用法可见<a href="https://www.cnblogs.com/yanghj010/p/10875151.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanghj010/p/10875151.html</a> \<br>可以使用在线cron表达式生成器对执行时间进行配置，生成器链接：<br><a href="https://cron.qqe2.com/" target="_blank" rel="noopener">https://cron.qqe2.com/</a></p>
<h1 id="性能指标与参数调整"><a href="#性能指标与参数调整" class="headerlink" title="性能指标与参数调整"></a>性能指标与参数调整</h1><h2 id="Redis单机性能测试"><a href="#Redis单机性能测试" class="headerlink" title="Redis单机性能测试"></a>Redis单机性能测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[dx@IPIR-dx ~]$ redis-benchmark -t get -c 100 -n 1000000</span><br><span class="line">====== GET ======</span><br><span class="line">  1000000 requests completed in 23.73 seconds</span><br><span class="line">  100 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">0.23% &lt;= 1 milliseconds</span><br><span class="line">98.86% &lt;= 2 milliseconds</span><br><span class="line">99.96% &lt;= 3 milliseconds</span><br><span class="line">99.99% &lt;= 4 milliseconds</span><br><span class="line">100.00% &lt;= 5 milliseconds</span><br><span class="line">100.00% &lt;= 6 milliseconds</span><br><span class="line">100.00% &lt;= 106 milliseconds</span><br><span class="line">100.00% &lt;= 107 milliseconds</span><br><span class="line">100.00% &lt;= 107 milliseconds</span><br><span class="line">42144.30 requests per second</span><br></pre></td></tr></table></figure>
<h2 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h2><p><strong>测试工具</strong> ：jemeter</p>
<p><strong>测试规模</strong> ：</p>
<ol>
<li>小测试 - 1000用户，每人发送20次，共2万个请求， </li>
<li>中测试 - 5000用户，每人发送20次，共10万个请求</li>
<li>大测试：10000用户，每人发送20次，共20万个请求</li>
</ol>
<p><strong>测试持续时间</strong> ： 60s, 到时之后将自动停止发送请求，但可能有未执行完的请求会继续排队直至执行完成。</p>
<p><strong>测试接口</strong>：message/countMessages</p>
<p><strong>测试环境</strong>：i5-6300hq, jvm heap大小为3.53gb</p>
<p><strong>tomcat默认配置</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat:</span></span><br><span class="line">  <span class="attr">uri-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">  <span class="attr">max-connections:</span> <span class="number">8192</span> <span class="comment"># 最大连接数</span></span><br><span class="line">  <span class="attr">threads:</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">200</span></span><br><span class="line">  <span class="attr">accept-count:</span> <span class="number">100</span> <span class="comment"># 请求等待队列</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>测试配置</th>
<th>请求数量</th>
<th>吞吐量/s</th>
<th>最小返回耗时(ms)</th>
<th>最大耗时</th>
<th>平均耗时</th>
<th>错误率</th>
<th>接收速率</th>
</tr>
</thead>
<tbody>
<tr>
<td>无redis</td>
<td>1790</td>
<td>6.2</td>
<td>4998</td>
<td>123975</td>
<td>70637</td>
<td>68.32%</td>
<td>1.59kb/s</td>
</tr>
<tr>
<td>单redis-小测试</td>
<td>20000</td>
<td>2035</td>
<td>5</td>
<td>3561</td>
<td>449</td>
<td>0.00%</td>
<td>443kb/s</td>
</tr>
<tr>
<td>单redis-大测试</td>
<td>198674</td>
<td>2465</td>
<td>1</td>
<td>3497</td>
<td>481</td>
<td>1.5%</td>
<td>1519kb/s</td>
</tr>
</tbody>
</table>
</div>
<p>在单redis-大测试中，出现的异常为HttpHostConnectException。Connect to localhost:8080 failed: Connection refused: connect。这是tomcat可以容纳的同时链接数太少造成的。接下来更新tomcat的配置，将max-connection调为20000；</p>
<h3 id="tomcat配置更新后测试【默认带有redis缓存功能】"><a href="#tomcat配置更新后测试【默认带有redis缓存功能】" class="headerlink" title="tomcat配置更新后测试【默认带有redis缓存功能】"></a>tomcat配置更新后测试【默认带有redis缓存功能】</h3><p><strong>tomcat中配置</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat:</span></span><br><span class="line">  <span class="attr">uri-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">  <span class="attr">max-connections:</span> <span class="number">20000</span> <span class="comment"># 最大连接数</span></span><br><span class="line">  <span class="attr">threads:</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">1000</span> <span class="comment"># 最大线程数</span></span><br><span class="line">  <span class="attr">accept-count:</span> <span class="number">1000</span> <span class="comment"># 请求等待队列</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>测试配置</th>
<th>请求数量</th>
<th>吞吐量/s</th>
<th>最小返回耗时(ms)</th>
<th>最大耗时</th>
<th>平均耗时</th>
<th>错误率</th>
<th>接收速率</th>
</tr>
</thead>
<tbody>
<tr>
<td>tomcat默认-大测试-local</td>
<td>198674</td>
<td>2465</td>
<td>1</td>
<td>3497</td>
<td>481</td>
<td>1.5%</td>
<td>1519kb/s</td>
</tr>
<tr>
<td>tomcat中-大测试-local</td>
<td>200000</td>
<td>2492</td>
<td>3</td>
<td>7850</td>
<td>1264</td>
<td>0.00%</td>
<td>542kb/s</td>
</tr>
</tbody>
</table>
</div>
<p>在单redis-大测试中，出现的异常HttpHostConnectException在tomcat中-大测试-local中并没有出现，因此可以断定增加tomcat配置可以增加连接的数目，8092的默认数目不够10000的需求，因此出现了异常。</p>
<h2 id="server测试"><a href="#server测试" class="headerlink" title="server测试"></a>server测试</h2><p>之前的测试程序和springboot程序运行在同一台机器上，主要是为了消除网络时延对于测试的影响。但是这种情况下，两个程序会争夺系统资源，可能无法将测试结果准确表现出来。因此<strong>基于tomcat中配置</strong>，在服务器上用docker搭建了测试环境。</p>
<p><strong>测试环境</strong>：Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz。jvm堆大小为8g。</p>
<p>jmeter设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number of Threads: 1000</span><br><span class="line">Ramp-up period: 0</span><br><span class="line">Loop Count: 20</span><br><span class="line">Dutation: 120</span><br><span class="line">对于中测试，Number of Threads = 5000， 其余不变。</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>测试配置</th>
<th>请求数量</th>
<th>吞吐量/s</th>
<th>最小返回耗时(ms)</th>
<th>最大耗时</th>
<th>平均耗时</th>
<th>错误率</th>
<th>接收速率</th>
</tr>
</thead>
<tbody>
<tr>
<td>单redis-小测试</td>
<td>20000</td>
<td>2035</td>
<td>5</td>
<td>3561</td>
<td>449</td>
<td>0.00%</td>
<td>443kb/s</td>
</tr>
<tr>
<td>tomcat中-小测试-server</td>
<td>20000</td>
<td>311</td>
<td>3</td>
<td>5998</td>
<td>814</td>
<td>0.00%</td>
<td>67.78kb/s</td>
</tr>
<tr>
<td>tomcat中-中测试-server</td>
<td>100000</td>
<td>818.2</td>
<td>5</td>
<td>31532</td>
<td>4924</td>
<td>2.22%</td>
<td>218.90</td>
</tr>
</tbody>
</table>
</div>
<p>tomcat中-中测试-server出现了错误。全部为java.net.SocketException,Non HTTP response message: Connection reset，主要问题在于网络。</p>
<p><strong>本地测试和server测试吞吐量对比：</strong></p>
<p>本地测试吞吐量更高，而且由于网络带来的时延，平均耗时约为server的一半。接收速率也高一些。</p>
<h3 id="server测试中的问题"><a href="#server测试中的问题" class="headerlink" title="server测试中的问题"></a>server测试中的问题</h3><ol>
<li><p>Non HTTP response code: java.net.BindException,Non HTTP response message: Address already in use: connect</p>
<p>ephemeral TCP ports使用量到达了上限，通过增加ephemeral ports的最大数量解决。<a href="https://www.baselogic.com/2011/11/23/solved-java-net-bindexception-address-use-connect-issue-windows/" target="_blank" rel="noopener">方案链接</a></p>
</li>
<li><p>Non HTTP response code: java.net.SocketException,Non HTTP response message: Connection reset</p>
</li>
<li><p>Non HTTP response code: java.net.SocketTimeoutException,Non HTTP response message: Read timed out</p>
</li>
<li><p>Non HTTP response code: org.apache.http.conn.HttpHostConnectException,Non HTTP response message: Connect to 192.168.55.215:8080 [/192.168.55.215] failed: Connection timed out: connect</p>
</li>
<li><p>Non HTTP response code: java.net.SocketException,Non HTTP response message: Software caused connection abort: connect</p>
</li>
</ol>
<p>If your Jmeter is eating all resources will your application will get anything (Simple answer is NO) Thus application will go down and you will start getting timeout errors or socket exceptions.</p>
<p>If you have jmeter and application on diff machines then still 10000 users in 1 second is very high load for a normal application and it is obvious that you will face such errors. Try running test with realistic load that is expected for your application with given hw. Maybe 100 users in 1 second and gradually increase them to expected value.</p>
<h1 id="查询优化-分库分表"><a href="#查询优化-分库分表" class="headerlink" title="查询优化-分库分表"></a>查询优化-分库分表</h1><p>打开慢查询log， 将慢查询记录阈值设置为5秒。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- show variables like '%slow%'; </span></span><br><span class="line"><span class="comment">-- set global slow_query_log = on;</span></span><br><span class="line"><span class="comment">-- show variables like '%long_query_time%';</span></span><br><span class="line"><span class="comment">-- set global long_query_time = 5;</span></span><br></pre></td></tr></table></figure>
<h2 id="未分库分表迁移到分库分表的方法"><a href="#未分库分表迁移到分库分表的方法" class="headerlink" title="未分库分表迁移到分库分表的方法"></a>未分库分表迁移到分库分表的方法</h2><p>在分库上配置适用于mybatis的sharding-jdbc方案。</p>
<p>​                <img src="https://i.loli.net/2021/07/17/fISMtouBeV5kwgH.png" alt="img">        </p>
<p>​    现在需要将旧库的数据迁移到新库上。主要的方案有停机迁移和非停机迁移两种。为了能在迁移的过程中不影响原数据库的使用，采用双写迁移方法。</p>
<p><img src="https://i.loli.net/2021/06/24/LC3iJPNO5U2xcyk.png" alt="表拆分示意图"></p>
<h3 id="方案1-使用ResourceDatabasePopulator进行迁移"><a href="#方案1-使用ResourceDatabasePopulator进行迁移" class="headerlink" title="方案1 使用ResourceDatabasePopulator进行迁移"></a><strong>方案1 使用</strong>ResourceDatabasePopulator进行迁移</h3><p>首先使用mysqldump将原库中的数据导出为sql脚本格式，然后利用Springboot自带的ResourceDatabasePopulator将sql脚本导入。这里导出的sql脚本大小为4.7GB。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializeData</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"><span class="meta">@EventListener</span>(ApplicationReadyEvent<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">loadData</span>() </span>&#123;</span><br><span class="line">ResourceDatabasePopulator resourceDatabasePopulator = <span class="keyword">new</span> ResourceDatabasePopulator(<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="string">"UTF-8"</span>, <span class="keyword">new</span> FileSystemResource(<span class="string">"posys_message.sql"</span>));</span><br><span class="line">        resourceDatabasePopulator.execute(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内存大小为16g的电脑上启动Springboot程序，报错为Failed to execute database script; nested exception is java.lang.OutOfMemoryError : heap，堆内存溢出了。然后试图将堆内存调大，发现还是会出现内存溢出异常——系统内存大小无法满足需要分配的堆内存大小。</p>
<h3 id="方案2-从旧库读取，然后插入新库中"><a href="#方案2-从旧库读取，然后插入新库中" class="headerlink" title="方案2 从旧库读取，然后插入新库中"></a><strong>方案2 从旧库读取，然后插入新库中</strong></h3><p>根据mysql<a href="https://dev.mysql.com/doc/refman/8.0/en/insert-optimization.html" target="_blank" rel="noopener">开发文档</a>中查询的优化，在插入语句中级联多条记录会增加查询的速度。插入一条语句时需要的时间主要由以下因素决定，后面的数字代表耗费的时间所占的比例。</p>
<ul>
<li>Connecting: (3)</li>
<li>Sending query to server: (2)</li>
<li>Parsing query: (2)</li>
<li>Inserting row: (1 × size of row)</li>
<li>Inserting indexes: (1 × number of indexes)</li>
<li>Closing: (1)</li>
</ul>
<p>因此，在一条语句中包含更多条数据可以节省建立连接、解析语句、关闭连接的时间。同时，在新库中将索引暂时关闭，也是有益于数据插入的快速进行的。</p>
<p>不同数据量测试5次，结果如下：</p>
<p>单独插入50000条数据平均耗时：233748ms<br>批量插入50000条数据平均耗时：2590ms<br>对比：效率差50倍<br>单独插入10000条数据平均耗时：22036ms<br>批量插入10000条数据平均耗时：3330ms<br>对比：效率差6倍<br>单独插入1000条数据平均耗时：3122ms<br>批量插入1000条数据平均耗时：374ms<br>对比：效率差8倍</p>
<p>其实最快的方式是从文本中直接加载表，这比INSERT语句快20多倍。但是由于这里使用了分表策略，加载时需要考虑数据的哈希定位库表的问题，因此只能选择语句插入的方式。</p>
<p>​                 <img src="https://i.loli.net/2021/07/17/Da5XvPg4qc3jomN.png" alt="img">        </p>
<p>首先在数据库中记录counter, 保存下一次迁移时的起始id和终止id, 如上图所示。然后主要的工作分为三部分：</p>
<ol>
<li>从旧库中批量读取，从起始id依次读到终止id。</li>
<li>向新库中批量插入。</li>
<li>递归调用当前函数，进行下一批数据的迁移。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">()</span></span>&#123;</span><br><span class="line">            logger.warn(<span class="string">"开始迁移"</span>);</span><br><span class="line">            List&lt;Integer&gt; idList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取上图counter，分别为start和end</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                idList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Message&gt; oldMessages;</span><br><span class="line">    		<span class="comment">// select...in子句取出源库中的所有数据</span></span><br><span class="line">            oldMessages = messageMapper.selectIdIn(idList);</span><br><span class="line">            <span class="keyword">if</span> (oldMessages.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将数据批量插入到分库分表中，这种批量插入的方式比单条插入快很多</span></span><br><span class="line">                <span class="keyword">int</span> res = messageMapper.batchInsert(oldMessages);</span><br><span class="line">                logger.warn(<span class="string">"成功插入"</span> + res + <span class="string">"个"</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 更新计数器</span></span><br><span class="line">            <span class="keyword">int</span> newStart = end + <span class="number">1</span>;</span><br><span class="line">            end = end + end - start + <span class="number">1</span>;</span><br><span class="line">            String newCounter = newStart + <span class="string">" "</span> + end;</span><br><span class="line">            <span class="comment">// 将新的计数器信息newCounter存入数据库</span></span><br><span class="line">            System.gc();</span><br><span class="line">    		<span class="comment">// 强制进行gc</span></span><br><span class="line">            migrate();</span><br><span class="line">    		<span class="comment">// 进行下一次迁移，这里使用递归调用的方式，虽然速度会慢一些，但是比较可靠，不容易出错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在插入时不断监看log，如果发生错误应及时修正。</p>
<p>​                 <img src="https://i.loli.net/2021/07/17/dIUNEB2J4aqZSjt.png" alt="img">        </p>
<h2 id="分库分表前后接口耗时测试"><a href="#分库分表前后接口耗时测试" class="headerlink" title="分库分表前后接口耗时测试"></a>分库分表前后接口耗时测试</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>countMessages（index）</th>
<th>getKeywordCount</th>
</tr>
</thead>
<tbody>
<tr>
<td>单库单表</td>
<td>26708</td>
<td>45476（ALL）</td>
</tr>
<tr>
<td>双库四表</td>
<td>9513.6（单表4.297）</td>
<td>15263（单表5827）（ALL）</td>
</tr>
<tr>
<td>单库单表+索引</td>
<td>—</td>
<td>2049（index）</td>
</tr>
<tr>
<td>双库四表+索引</td>
<td>—</td>
<td>2395（单表1339）（index）</td>
</tr>
</tbody>
</table>
</div>
<p>利用EXPLAIN来查看上述两条语句的执行计划，并在标题栏中标注出来。ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）。</p>
<p><strong>分库效果小结：</strong>通过分库可以减少需要扫描全部索引的时间，因此countMessages分库分表执行时间比原来快很多。在getKeywordCount测试中，由于归并需要时间，因此在有索引的情况下，虽然单个小表查询时间比原来少，但是得到汇总结果的时间会多于单表下的查询时间。</p>
<h2 id="分库分表带来的复杂性"><a href="#分库分表带来的复杂性" class="headerlink" title="分库分表带来的复杂性"></a>分库分表带来的复杂性</h2><h3 id="跨库关联查询"><a href="#跨库关联查询" class="headerlink" title="跨库关联查询"></a>跨库关联查询</h3><p>有几种方案可以解决：</p>
<ul>
<li>字段冗余：把需要关联的字段放入主表中，避免 join 操作；</li>
<li>数据抽象：通过ETL等将数据汇合聚集，生成新的表；</li>
<li>全局表：比如一些基础表可以在每个数据库中都放一份；</li>
<li>应用层组装：将基础数据查出来，通过应用程序计算组装；</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>单数据库可以用本地事务搞定，使用多数据库就只能通过分布式事务解决了。</p>
<p>常用解决方案有：基于可靠消息（MQ）的解决方案、两阶段事务提交、柔性事务等。</p>
<p>Sharding-jdbc中本地事务完全支持非跨库事务：例如仅分表，或分库但是路由的结果在单库中。同时完全支持因逻辑异常导致的跨库事务。例如：同一事务中，跨两个库更新。更新完毕后，抛出空指针，则两个库的内容都能回滚。但是不支持因网络、硬件异常导致的跨库事务。例如：同一事务中，跨两个库更新，更新完毕后、未提交之前，第一个库宕机，则只有第二个库数据提交。</p>
<p>因此使用两阶段事务来完全支持跨库事务。在sharding-jdbc中默认使用Atomikos，支持使用SPI的方式加载其他XA事务管理器。</p>
<p>不过，XA 并不是 Java 的技术规范（XA 提出那时还没有 Java），而是一套语言无关的通用规范，所以 Java 中专门定义了<a href="https://www.jcp.org/en/jsr/detail?id=907" target="_blank" rel="noopener">JSR 907 Java Transaction API</a>，基于 XA 模式在 Java 语言中的实现了全局事务处理的标准，这也就是我们现在所熟知的 JTA。JTA 最主要的两个接口是：</p>
<ul>
<li>事务管理器的接口：<code>javax.transaction.TransactionManager</code>。这套接口是给 Java EE 服务器提供容器事务（由容器自动负责事务管理）使用的，还提供了另外一套<code>javax.transaction.UserTransaction</code>接口，用于通过程序代码手动开启、提交和回滚事务。</li>
<li>满足 XA 规范的资源定义接口：<code>javax.transaction.xa.XAResource</code>，任何资源（JDBC、JMS 等等）如果想要支持 JTA，只要实现 XAResource 接口中的方法即可。</li>
</ul>
<p>JTA 原本是 Java EE 中的技术，一般情况下应该由 JBoss、WebSphere、WebLogic 这些 Java EE 容器来提供支持，但现在<a href="https://web.archive.org/web/20100414140721/http://docs.codehaus.org/display/BTM/Home" target="_blank" rel="noopener">Bittronix</a>、<a href="http://www.atomikos.com/Main/TransactionsEssentials" target="_blank" rel="noopener">Atomikos</a>和<a href="http://www.jboss.org/jbosstm" target="_blank" rel="noopener">JBossTM</a>（以前叫 Arjuna）都以 JAR 包的形式实现了 JTA 的接口，称为 JOTM（Java Open Transaction Manager），使得我们能够在 Tomcat、Jetty 这样的 Java SE 环境下也能使用 JTA。</p>
<p>XA 将事务提交拆分成为两阶段过程：</p>
<ul>
<li><strong>准备阶段</strong>：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与的是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。这里所说的准备操作跟人类语言中通常理解的准备并不相同，对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。</li>
<li><strong>提交阶段</strong>：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载操作。</li>
</ul>
<p><img src="https://i.loli.net/2021/06/23/dL54u9iBDRQt6sg.png" alt="image-20210623180351644"></p>
<p>两段式提交原理简单，并不难实现，但有几个非常显著的缺点：</p>
<ul>
<li><strong>单点问题</strong>：协调者在两段提交中具有举足轻重的作用，协调者等待参与者回复时可以有超时机制，允许参与者宕机，但参与者等待协调者指令时无法做超时处理。一旦宕机的不是其中某个参与者，而是协调者的话，所有参与者都会受到影响。如果协调者一直没有恢复，没有正常发送 Commit 或者 Rollback 的指令，那所有参与者都必须一直等待。</li>
<li><strong>性能问题</strong>：两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record），整个过程将持续到参与者集群中最慢的那一个处理操作结束为止，这决定了两段式提交的性能通常都较差。</li>
<li><strong>一致性风险</strong>：前面已经提到，两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。宕机恢复能力这一点不必多谈，1985 年 Fischer、Lynch、Paterson 提出了“<a href="https://en.wikipedia.org/wiki/Consensus_(computer_science" target="_blank" rel="noopener">FLP 不可能原理</a>#Solvability_results_for_some_agreement_problems)”，证明了如果宕机最后不能恢复，那就不存在任何一种分布式协议可以正确地达成一致性结果。该原理在分布式中是与“CAP 不可兼得原理“齐名的理论。而网络稳定性带来的一致性风险是指：尽管提交阶段时间很短，但这仍是一段明确存在的危险期，如果协调者在发出准备指令后，根据收到各个参与者发回的信息确定事务状态是可以提交的，协调者会先持久化事物状态，并提交自己的事务，如果这时候网络忽然被断开，无法再通过网络向所有参与者发出 Commit 指令的话，就会导致部分数据（协调者的）已提交，但部分数据（参与者的）既未提交，也没有办法回滚，产生了数据不一致的问题。</li>
</ul>
<h3 id="排序、分页、函数计算问题"><a href="#排序、分页、函数计算问题" class="headerlink" title="排序、分页、函数计算问题"></a>排序、分页、函数计算问题</h3><p>使用SQL时order by, limit关键字需要特殊处理，一般来说采用分片的思路</p>
<p>现在某个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终得到结果。</p>
<h3 id="分布式id"><a href="#分布式id" class="headerlink" title="分布式id"></a>分布式id</h3><p>如果使用mysql可以在单库单表中使用id自增作为主键，分库分表就不行了，会出现id重复。</p>
<p>可以通过以下分布式id生成方案解决：</p>
<ul>
<li>UUID</li>
<li>基于数据库自增单独维护一张 ID表</li>
<li>号段模式</li>
<li>Redis 缓存</li>
<li>雪花算法（Snowflake）</li>
<li>百度uid-generator</li>
<li>美团Leaf</li>
<li>滴滴Tinyid</li>
</ul>
<p>本项目中，表插入操作在主库posys中进行，插入后会运行同步插件，实现新旧库的一致。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/02/%E8%A7%A3%E5%86%B3mysql%E6%97%A0%E6%B3%95%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98/" rel="prev" title="解决Mysql无法远程连接的问题">
      <i class="fa fa-chevron-left"></i> 解决Mysql无法远程连接的问题
    </a></div>
      <div class="post-nav-item">
    <a href="/2222/11/28/%E6%9C%80%E5%B8%B8%E8%AE%BF%E9%97%AE/" rel="next" title="最常访问">
      最常访问 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面向互联网信息的舆情检测与预警系统"><span class="nav-number">1.</span> <span class="nav-text">面向互联网信息的舆情检测与预警系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#目录"><span class="nav-number">1.1.</span> <span class="nav-text">目录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#环境搭建"><span class="nav-number">2.</span> <span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#配置过程"><span class="nav-number">2.1.</span> <span class="nav-text">配置过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取远程develop分支"><span class="nav-number">2.2.</span> <span class="nav-text">获取远程develop分支</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#项目组件介绍"><span class="nav-number">3.</span> <span class="nav-text">项目组件介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存机制"><span class="nav-number">3.1.</span> <span class="nav-text">缓存机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时任务"><span class="nav-number">3.2.</span> <span class="nav-text">定时任务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能指标与参数调整"><span class="nav-number">4.</span> <span class="nav-text">性能指标与参数调整</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis单机性能测试"><span class="nav-number">4.1.</span> <span class="nav-text">Redis单机性能测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#负载测试"><span class="nav-number">4.2.</span> <span class="nav-text">负载测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tomcat配置更新后测试【默认带有redis缓存功能】"><span class="nav-number">4.2.1.</span> <span class="nav-text">tomcat配置更新后测试【默认带有redis缓存功能】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#server测试"><span class="nav-number">4.3.</span> <span class="nav-text">server测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#server测试中的问题"><span class="nav-number">4.3.1.</span> <span class="nav-text">server测试中的问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查询优化-分库分表"><span class="nav-number">5.</span> <span class="nav-text">查询优化-分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#未分库分表迁移到分库分表的方法"><span class="nav-number">5.1.</span> <span class="nav-text">未分库分表迁移到分库分表的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方案1-使用ResourceDatabasePopulator进行迁移"><span class="nav-number">5.1.1.</span> <span class="nav-text">方案1 使用ResourceDatabasePopulator进行迁移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方案2-从旧库读取，然后插入新库中"><span class="nav-number">5.1.2.</span> <span class="nav-text">方案2 从旧库读取，然后插入新库中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分库分表前后接口耗时测试"><span class="nav-number">5.2.</span> <span class="nav-text">分库分表前后接口耗时测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分库分表带来的复杂性"><span class="nav-number">5.3.</span> <span class="nav-text">分库分表带来的复杂性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#跨库关联查询"><span class="nav-number">5.3.1.</span> <span class="nav-text">跨库关联查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式事务"><span class="nav-number">5.3.2.</span> <span class="nav-text">分布式事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序、分页、函数计算问题"><span class="nav-number">5.3.3.</span> <span class="nav-text">排序、分页、函数计算问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式id"><span class="nav-number">5.3.4.</span> <span class="nav-text">分布式id</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dxzmpk</p>
  <div class="site-description" itemprop="description">Learning in Harbin Institute of Technology</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dxzmpk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1278837449&web_id=1278837449"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 't8n8RTilca5Gm0vKToaMrjRU-gzGzoHsz',
      appKey     : 'x4Jty8MrDpczjPANtbbGhwXX',
      placeholder: "请留下一点痕迹吧, 评论将永远留存",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
