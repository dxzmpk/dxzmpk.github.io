<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E8%A7%86%E5%8A%9B%E8%A1%A8%20(1).svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E8%A7%86%E5%8A%9B%E8%A1%A8.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dxzmpk.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
<meta property="og:type" content="website">
<meta property="og:title" content="董雄的博客">
<meta property="og:url" content="https://dxzmpk.github.io/">
<meta property="og:site_name" content="董雄的博客">
<meta property="og:description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="董雄">
<meta property="article:tag" content="nlp">
<meta property="article:tag" content=" cs">
<meta property="article:tag" content=" hit">
<meta property="article:tag" content=" transformers">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dxzmpk.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>董雄的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">董雄的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">7分nlp,3分计算机基础</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/04/23/HuggingFace-transformers%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%9C%A8%E4%B8%8B%E6%B8%B8%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/23/HuggingFace-transformers%E7%B3%BB%E5%88%97%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%9C%A8%E4%B8%8B%E6%B8%B8%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">HuggingFace-Transformers系列的介绍以及在下游任务中的使用</a>
        </h2>

        <div class="post-meta">
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-23 09:02:46" itemprop="dateCreated datePublished" datetime="2020-04-23T09:02:46+08:00">2020-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-11 22:50:43" itemprop="dateModified" datetime="2020-05-11T22:50:43+08:00">2020-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nlp/" itemprop="url" rel="index"><span itemprop="name">nlp</span></a>
                </span>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h1><p>这篇博客主要面向对<strong>Bert</strong>系列在<strong>Pytorch</strong>上应用感兴趣的同学，将涵盖的主要内容是：Bert系列有关的论文，<a href="https://huggingface.co/transformers/installation.html#" target="_blank" rel="noopener">Huggingface</a>的实现，以及如何在不同下游任务中使用预训练模型。</p>
<p>看过这篇博客，你将了解：</p>
<ul>
<li>Transformers实现的介绍，不同的Tokenizer和Model如何使用。</li>
<li>如何利用HuggingFace的实现自定义你的模型，如果你想利用这个库实现自己的下游任务，而不想过多关注其实现细节的话，那么这篇文章将会成为很好的参考。</li>
</ul>
<h2 id="Huggingface-transformers介绍"><a href="#Huggingface-transformers介绍" class="headerlink" title="Huggingface-transformers介绍"></a>Huggingface-transformers介绍</h2><p><a href="https://huggingface.co/transformers/index.html" target="_blank" rel="noopener">transformers</a>（以前称为pytorch-transformers和pytorch-pretrained-bert）提供用于自然语言理解（NLU）和自然语言生成（NLG）的BERT家族通用结构（BERT，GPT-2，RoBERTa，XLM，DistilBert，XLNet等），包含超过32种、涵盖100多种语言的预训练模型。同时提供TensorFlow 2.0和PyTorch之间的高互通性。</p>
<p><strong>特性</strong>：</p>
<ul>
<li><p>与pytorch-transformers一样易于使用</p>
</li>
<li><p>像Keras一样强大而简洁</p>
</li>
<li><p>在NLU和NLG任务上表现良好</p>
</li>
<li><p>对于教育者和从业者的门槛低</p>
</li>
</ul>
<p><strong>现存的模型</strong>：</p>
<ul>
<li><p>Bert(基础版和巨人版, 是否区分大小写)， </p>
</li>
<li><p>GPT, GPT-2</p>
</li>
<li><p>Transformer-XL, XLNet, XLM</p>
</li>
<li><p>DistilBERT, DistilGPT2</p>
</li>
<li><p>CTRL</p>
</li>
<li><p>ALBERT, RoBERTa, XLM-RoBERTa</p>
</li>
<li><p>FlauBERT，CamemBERT</p>
</li>
<li>其他在各种下游任务上微调过的模型。</li>
<li>在多语言上训练的模型</li>
</ul>
<h1 id="所需的知识"><a href="#所需的知识" class="headerlink" title="所需的知识"></a>所需的知识</h1><p><a href="https://huggingface.co/transformers/installation.html#" target="_blank" rel="noopener">安装Huggface库</a>(需要预先安装pytorch)</p>
<p>在阅读这篇文章之前，如果你能将以下资料读一遍，或者看一遍的话，在后续的阅读过程中将极大地减少你陷入疑惑的概率。</p>
<ul>
<li>视频类内容：根据排序观看更佳<ul>
<li><a href="https://www.bilibili.com/video/BV17441137fa?from=search&amp;seid=17871853660365597030" target="_blank" rel="noopener">李宏毅关于Elmo, Bert, GPT的讲解</a></li>
<li><a href="https://www.bilibili.com/video/BV1Tt411M7Wp?from=search&amp;seid=194654766718455422" target="_blank" rel="noopener">Goebels关于transformerXL的讲解</a></li>
<li><a href="https://www.youtube.com/watch?v=H5vpBCLo74U" target="_blank" rel="noopener">Kilcher关于XLnet的讲解</a></li>
<li><a href="https://www.youtube.com/watch?v=vsGN8WqwvKg&amp;t=597s" target="_blank" rel="noopener">McCormick关于ALBERT的讲解</a></li>
</ul>
</li>
</ul>
<p><strong>或者</strong>，你更愿意去看论文的话：</p>
<ul>
<li>相关论文：根据排序阅读更佳<ul>
<li><a href="https://arxiv.org/abs/1810.04805" target="_blank" rel="noopener">BERT论文</a>, BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding, Authors: Jacob Devlin, Ming-Wei Chang, Kenton Lee, Kristina Toutanova</li>
<li><a href="https://arxiv.org/abs/1901.02860" target="_blank" rel="noopener">Transformer-XL论文</a>, Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context,  Authors: Zihang Dai, Zhilin Yang, Yiming Yang, William W. Cohen, Jaime Carbonell, Quoc V. Le and Ruslan Salakhutdinov.</li>
<li><a href="http://xxx.itp.ac.cn/abs/1906.08237" target="_blank" rel="noopener">XLNet论文</a>，XLNet: Generalized Autoregressive Pretraining for Language Understanding</li>
<li><a href="http://xxx.itp.ac.cn/abs/1909.11942" target="_blank" rel="noopener">ALBERT论文</a>，ALBERT: A Lite BERT for Self-supervised Learning of Language Representations</li>
<li><a href="http://xxx.itp.ac.cn/abs/1907.11692" target="_blank" rel="noopener">RoBERTa论文</a>， RoBERTa: A Robustly Optimized BERT Pretraining Approach</li>
<li><a href="http://xxx.itp.ac.cn/abs/1910.01108" target="_blank" rel="noopener">DistilBERT论文</a>，DistilBERT, a distilled version of BERT: smaller, faster, cheaper and lighter</li>
</ul>
</li>
</ul>
<h1 id="HuggingFace模型加载-下游任务使用"><a href="#HuggingFace模型加载-下游任务使用" class="headerlink" title="HuggingFace模型加载+下游任务使用"></a>HuggingFace模型加载+下游任务使用</h1><h2 id="项目组件"><a href="#项目组件" class="headerlink" title="项目组件"></a>项目组件</h2><p>一个完整的transformer模型主要包含三部分：</p>
<ol>
<li><p><strong>Config</strong>，控制模型的名称、最终输出的样式、隐藏层宽度和深度、激活函数的类别等。将Config类导出时文件格式为 json格式，就像下面这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"attention_probs_dropout_prob"</span>: <span class="number">0.1</span>,</span><br><span class="line">  <span class="attr">"hidden_act"</span>: <span class="string">"gelu"</span>,</span><br><span class="line">  <span class="attr">"hidden_dropout_prob"</span>: <span class="number">0.1</span>,</span><br><span class="line">  <span class="attr">"hidden_size"</span>: <span class="number">768</span>,</span><br><span class="line">  <span class="attr">"initializer_range"</span>: <span class="number">0.02</span>,</span><br><span class="line">  <span class="attr">"intermediate_size"</span>: <span class="number">3072</span>,</span><br><span class="line">  <span class="attr">"max_position_embeddings"</span>: <span class="number">512</span>,</span><br><span class="line">  <span class="attr">"num_attention_heads"</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">"num_hidden_layers"</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">"type_vocab_size"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"vocab_size"</span>: <span class="number">30522</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以通过config.json来实例化Config类，这是一个互逆的过程。</p>
</li>
<li><p><strong>Tokenizer</strong>，这是一个将纯文本转换为编码的过程。注意，Tokenizer并不涉及将词转化为词向量的过程，仅仅是将纯文本分词，添加[MASK]标记、[SEP]、[CLS]标记，并转换为字典索引。Tokenizer类导出时将分为三个文件，也就是：</p>
<ul>
<li><p>vocab.txt</p>
<p>词典文件，每一行为一个词或词的一部分</p>
</li>
<li><p>special_tokens_map.json 特殊标记的定义方式</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"unk_token"</span>: <span class="string">"[UNK]"</span>, <span class="attr">"sep_token"</span>: <span class="string">"[SEP]"</span>, <span class="attr">"pad_token"</span>: <span class="string">"[PAD]"</span>, </span><br><span class="line"> <span class="attr">"cls_token"</span>: <span class="string">"[CLS]"</span>, <span class="attr">"mask_token"</span>: <span class="string">"[MASK]"</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tokenizer_config.json 配置文件，主要存储特殊的配置。</p>
</li>
</ul>
</li>
<li><p><strong>Model</strong>，也就是各种各样的模型。除了初始的Bert、GPT等基本模型，针对下游任务，还定义了诸如<code>BertForQuestionAnswering</code>等下游任务模型。模型导出时将生成<code>config.json</code>和<code>pytorch_model.bin</code>参数文件。前者就是1中的配置文件，这和我们的直觉相同，即config和model应该是紧密联系在一起的两个类。后者其实和torch.save()存储得到的文件是相同的，这是因为Model都直接或者间接继承了Pytorch的Module类。从这里可以看出，HuggingFace在实现时很好地尊重了Pytorch的原生API。</p>
</li>
</ol>
<h2 id="导入Bert系列基本模型的方法"><a href="#导入Bert系列基本模型的方法" class="headerlink" title="导入Bert系列基本模型的方法"></a>导入Bert系列基本模型的方法</h2><h3 id="通过官网自动导入"><a href="#通过官网自动导入" class="headerlink" title="通过官网自动导入"></a>通过官网自动导入</h3><p>官方文档中<a href="https://huggingface.co/transformers/quickstart.html#" target="_blank" rel="noopener">初始教程</a>提供的方法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from transformers import BertModel</span></span><br><span class="line"><span class="comment"># Load pre-trained model (weights)</span></span><br><span class="line"><span class="comment"># model = BertModel.from_pretrained('bert-base-uncased')</span></span><br></pre></td></tr></table></figure>
<p>这个方法需要从官方的s3数据库下载模型配置、参数等信息（代码中已配置好位置）。这个方法虽然简单，但是在国内并不可用。当然你可以先尝试一下，不过会有很大的概率无法下载模型。</p>
<h3 id="手动下载模型信息并导入"><a href="#手动下载模型信息并导入" class="headerlink" title="手动下载模型信息并导入"></a>手动下载模型信息并导入</h3><ol>
<li><p>在HuggingFace<a href="https://huggingface.co/models" target="_blank" rel="noopener">官方模型库</a>上找到需要下载的模型，点击模型链接， 这个例子使用的是bert-base-uncased模型</p>
</li>
<li><p>点击<a href="https://huggingface.co/bert-base-uncased#" target="_blank" rel="noopener">List all files in model</a>，将其中的文件一一下载到同一目录中。例如，对于XLNet:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># List of model files</span><br><span class="line">config.json	782.0B</span><br><span class="line">pytorch_model.bin	445.4MB</span><br><span class="line">special_tokens_map.json	202.0B</span><br><span class="line">spiece.model	779.3KB</span><br><span class="line">tokenizer_config.json	2.0B</span><br></pre></td></tr></table></figure>
<p>但是这种方法有时也会不可用。如果您可以将Transformers预训练模型上传到迅雷等网盘的话，请在评论区告知，我会添加在此博客中，并为您添加博客友链。</p>
</li>
<li><p>通过下载好的路径导入模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> transformers</span><br><span class="line">MODEL_PATH = <span class="string">r"D:\transformr_files\bert-base-uncased/"</span></span><br><span class="line"><span class="comment"># a.通过词典导入分词器</span></span><br><span class="line">tokenizer = transformers.BertTokenizer.from_pretrained(<span class="string">r"D:\transformr_files\bert-base-uncased\bert-base-uncased-vocab.txt"</span>) </span><br><span class="line"><span class="comment"># b. 导入配置文件</span></span><br><span class="line">model_config = transformers.BertConfig.from_pretrained(MODEL_PATH)</span><br><span class="line"><span class="comment"># 修改配置</span></span><br><span class="line">model_config.output_hidden_states = <span class="literal">True</span></span><br><span class="line">model_config.output_attentions = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 通过配置和路径导入模型</span></span><br><span class="line">model = transformers.BertModel.from_pretrained(MODEL_PATH,config = model_config)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="利用分词器分词"><a href="#利用分词器分词" class="headerlink" title="利用分词器分词"></a>利用分词器分词</h3><p>利用分词器进行编码</p>
<ul>
<li><p>对于单句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encode仅返回input_ids</span></span><br><span class="line">tokenizer.encode(<span class="string">"i like you"</span>)</span><br><span class="line">Out : [<span class="number">101</span>, <span class="number">1045</span>, <span class="number">2066</span>, <span class="number">2017</span>, <span class="number">102</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于多句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encode_plus返回所有编码信息</span></span><br><span class="line">sen_code = tokenizer.encode_plus(<span class="string">"i like you"</span>, <span class="string">"but not him"</span>)</span><br><span class="line">Out : </span><br><span class="line">    &#123;<span class="string">'input_ids'</span>: [<span class="number">101</span>, <span class="number">1045</span>, <span class="number">2066</span>, <span class="number">2017</span>, <span class="number">102</span>, <span class="number">2021</span>, <span class="number">2025</span>, <span class="number">2032</span>, <span class="number">102</span>],</span><br><span class="line">     <span class="string">'token_type_ids'</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">     <span class="string">'attention_mask'</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>模型的所有分词器都是在PreTrainedTokenizer中实现的，分词的结果主要有以下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">input_ids: list[int],</span><br><span class="line">token_type_ids: list[int] if return_token_type_ids is True (default)</span><br><span class="line">attention_mask: list[int] if return_attention_mask is True (default)</span><br><span class="line">overflowing_tokens: list[int] if a max_length is specified and 		return_overflowing_tokens is True</span><br><span class="line">num_truncated_tokens: int if a max_length is specified and return_overflowing_tokens is True</span><br><span class="line">special_tokens_mask: list[int] if add_special_tokens if set to True and return_special_tokens_mask is True</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编码解释：</p>
<ul>
<li>‘input_ids’：顾名思义，是单词在词典中的编码</li>
<li>‘token_type_ids’， 区分两个句子的编码</li>
<li>‘attention_mask’,  指定对哪些词进行self-Attention操作</li>
<li>‘overflowing_tokens’, 当指定最大长度时，溢出的单词</li>
<li>‘num_truncated_tokens’, 溢出的token数量</li>
<li>‘return_special_tokens_mask’，如果添加特殊标记，则这是[0，1]的列表，其中0指定特殊添加的标记，而1指定序列标记</li>
</ul>
<h3 id="将input-ids转化回token"><a href="#将input-ids转化回token" class="headerlink" title="将input_ids转化回token"></a>将input_ids转化回token</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokenizer.convert_ids_to_tokens(sen_code[<span class="string">'input_ids'</span>])</span><br></pre></td></tr></table></figure>
<p>得到的结果是：</p>
<p><code>[&#39;[CLS]&#39;, &#39;i&#39;, &#39;like&#39;, &#39;you&#39;, &#39;[SEP]&#39;, &#39;but&#39;, &#39;not&#39;, &#39;him&#39;, &#39;[SEP]&#39;]</code></p>
<p>即tokenizer在编码时已经默认添加了标记。各模型对应的输入格式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bert:       [CLS] + tokens + [SEP] + padding</span><br><span class="line"></span><br><span class="line">roberta:    [CLS] + prefix_space + tokens + [SEP] + padding</span><br><span class="line"></span><br><span class="line">distilbert: [CLS] + tokens + [SEP] + padding</span><br><span class="line"></span><br><span class="line">xlm:        [CLS] + tokens + [SEP] + padding</span><br><span class="line"></span><br><span class="line">xlnet:      padding + tokens + [SEP] + [CLS]</span><br></pre></td></tr></table></figure>
<p>其中<code>[CLS]</code>对应分类等任务中的标记，<code>[SEP]</code>对应句子的结束，padding是当指定模型最大输入长度max_len时，需要补充的字符。</p>
<h3 id="对编码进行转换，以便输入Tensor"><a href="#对编码进行转换，以便输入Tensor" class="headerlink" title="对编码进行转换，以便输入Tensor"></a>对编码进行转换，以便输入Tensor</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">model.eval() <span class="comment"># 将模型设为验证模式</span></span><br><span class="line">input_ids = torch.tensor([sen_code[<span class="string">'input_ids'</span>]]) <span class="comment"># 添加batch维度并转化为tensor</span></span><br><span class="line">token_type_ids = torch.tensor([sen_code[<span class="string">'token_type_ids'</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="将分词结果输入模型，得到编码"><a href="#将分词结果输入模型，得到编码" class="headerlink" title="将分词结果输入模型，得到编码"></a>将分词结果输入模型，得到编码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将模型转化为eval模式</span></span><br><span class="line">model.eval()</span><br><span class="line"><span class="comment"># 将模型和数据转移到cuda, 若无cuda,可更换为cpu</span></span><br><span class="line">device = <span class="string">'cuda'</span></span><br><span class="line">tokens_tensor = input_ids.to(device)</span><br><span class="line">segments_tensors = token_type_ids.to(device)</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行编码</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="comment"># See the models docstrings for the detail of the inputs</span></span><br><span class="line">    outputs = model(tokens_tensor, token_type_ids=segments_tensors)</span><br><span class="line">    <span class="comment"># Transformers models always output tuples.</span></span><br><span class="line">    <span class="comment"># See the models docstrings for the detail of all the outputs</span></span><br><span class="line">    <span class="comment"># In our case, the first element is the hidden state of the last layer of the Bert model</span></span><br><span class="line">    encoded_layers = outputs</span><br><span class="line"><span class="comment"># 得到最终的编码结果encoded_layers</span></span><br></pre></td></tr></table></figure>
<p>Bert最终输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequence_output, pooled_output, (hidden_states), (attentions)</span><br></pre></td></tr></table></figure>
<p>以输入序列长度为14为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>index</th>
<th>名称</th>
<th>维度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>sequence_output</td>
<td>torch.Size([1, 14, 768])</td>
<td>输出序列</td>
</tr>
<tr>
<td>1</td>
<td>pooled_output</td>
<td>torch.Size([1, 768])</td>
<td>对输出序列进行pool操作的结果</td>
</tr>
<tr>
<td>2</td>
<td>(hidden_states)</td>
<td>tuple,13*torch.Size([1, 14, 768])</td>
<td>隐藏层状态(包括Embedding层)，取决于modelconfig中output_hidden_states</td>
</tr>
<tr>
<td>3</td>
<td>(attentions)</td>
<td>tuple,12*torch.Size([1, 12, 14, 14])</td>
<td>注意力层，取决于参数中output_attentions</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bert总结"><a href="#Bert总结" class="headerlink" title="Bert总结"></a>Bert总结</h3><p>这一节我们以Bert为例对模型整体的流程进行了了解。之后的很多模型都基于Bert，并基于Bert进行了少量的调整。其中的输出和输出参数也有很多重复的地方。</p>
<h2 id="利用预训练模型在下游任务上微调"><a href="#利用预训练模型在下游任务上微调" class="headerlink" title="利用预训练模型在下游任务上微调"></a>利用预训练模型在下游任务上微调</h2><p>如开头所说，这篇文章重点在于”如何进行模型的调整以及输入输出的设定”, 以及”Transformer的实现进行简要的提及”, 所以，我们不会去介绍、涉及如何写train循环等话题，而仅仅专注于模型。也就是说，我们将止步于跑通一个模型，而不计批量数据预处理、训练、验证等过程。</p>
<p>同时，这里更看重如何基于Bert等初始模型在实际任务上进行微调，所以我们不会仅仅地导入已经在下游任务上训练好的模型参数，因为在这些模型上使用的方法和上一章的几乎完全相同。</p>
<p>这里的输入和输入以模型的预测过程为例。</p>
<h3 id="问答任务-via-Bert"><a href="#问答任务-via-Bert" class="headerlink" title="问答任务 via Bert"></a>问答任务 via Bert</h3><p><strong>任务输入</strong>：问题句，答案所在的文章 <code>&quot;Who was Jim Henson?&quot;, &quot;Jim Henson was a nice puppet&quot;</code></p>
<p><strong>任务输出</strong>：答案  <code>&quot;a nice puppet&quot;</code></p>
<p>现存的模型输入输出和任务的输入输出有一定差别，这也是在使用上需要区别的地方：</p>
<p><strong>模型输入</strong>：inputids, token_type_ids</p>
<p><strong>模型输出</strong>：start_scores, end_scores 形状都为<code>torch.Size([1, 14])</code>,其中<code>14</code>为序列长度，代表每个位置是开始/结束位置的概率。</p>
<p><strong>模型的构建</strong>：</p>
<p>一般情况下，一个基本模型对应一个Tokenizer, 所以并不存在对应于具体下游任务的Tokenizer。这里通过bert_model初始化BertForQuestionAnswering。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertTokenizer, BertForQuestionAnswering</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">MODEL_PATH = <span class="string">r"D:\transformr_files\bert-base-uncased/"</span></span><br><span class="line"><span class="comment"># 实例化tokenizer</span></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(<span class="string">r"D:\transformr_files\bert-base-uncased\bert-base-uncased-vocab.txt"</span>)</span><br><span class="line"><span class="comment"># 导入bert的model_config</span></span><br><span class="line">model_config = transformers.BertConfig.from_pretrained(MODEL_PATH)</span><br><span class="line"><span class="comment"># 首先新建bert_model</span></span><br><span class="line">bert_model = transformers.BertModel.from_pretrained(MODEL_PATH,config = model_config)</span><br><span class="line"><span class="comment"># 最终有两个输出，初始位置和结束位置（下面有解释）</span></span><br><span class="line">model_config.num_labels = <span class="number">2</span></span><br><span class="line"><span class="comment"># 同样根据bert的model_config新建BertForQuestionAnswering</span></span><br><span class="line">model = BertForQuestionAnswering(model_config)</span><br><span class="line">model.bert = bert_model</span><br></pre></td></tr></table></figure>
<p><strong>利用模型进行运算：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定模式</span></span><br><span class="line">model.eval()</span><br><span class="line">question, text = <span class="string">"Who was Jim Henson?"</span>, <span class="string">"Jim Henson was a nice puppet"</span></span><br><span class="line"><span class="comment"># 获取input_ids编码</span></span><br><span class="line">input_ids = tokenizer.encode(question, text)</span><br><span class="line"><span class="comment"># 手动进行token_type_ids编码，可用encode_plus代替</span></span><br><span class="line">token_type_ids = [<span class="number">0</span> <span class="keyword">if</span> i &lt;= input_ids.index(<span class="number">102</span>) <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(input_ids))]</span><br><span class="line"><span class="comment"># 得到评分, </span></span><br><span class="line">start_scores, end_scores = model(torch.tensor([input_ids]), token_type_ids=torch.tensor([token_type_ids]))</span><br><span class="line"><span class="comment"># 进行逆编码，得到原始的token </span></span><br><span class="line">all_tokens = tokenizer.convert_ids_to_tokens(input_ids)</span><br><span class="line"><span class="comment">#['[CLS]', 'who', 'was', 'jim', 'henson', '?', '[SEP]', 'jim', 'henson', 'was', 'a', 'nice', 'puppet', '[SEP]']</span></span><br></pre></td></tr></table></figure>
<p><strong>将模型输出转化为任务输出：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对输出的答案进行解码的过程</span></span><br><span class="line">answer = <span class="string">' '</span>.join(all_tokens[torch.argmax(start_scores) : torch.argmax(end_scores)+<span class="number">1</span>])</span><br><span class="line"><span class="comment"># assert answer == "a nice puppet" </span></span><br><span class="line"><span class="comment"># 这里因为没有经过微调，所以效果不是很好，输出结果不佳。</span></span><br><span class="line">print(answer)</span><br><span class="line"><span class="comment"># 'was jim henson ? [SEP] jim henson was a nice puppet [SEP]'</span></span><br></pre></td></tr></table></figure>
<h3 id="文本分类任务-情感分析等-via-XLNet"><a href="#文本分类任务-情感分析等-via-XLNet" class="headerlink" title="文本分类任务(情感分析等) via XLNet"></a>文本分类任务(情感分析等) via XLNet</h3><p><strong>任务输入</strong>：句子 <code>&quot;i like you, what about you&quot;</code></p>
<p><strong>任务输出</strong>：句子所属的类别 <code>class1</code></p>
<p><strong>模型输入</strong>：inputids, token_type_ids</p>
<p><strong>模型输出</strong>：logits, hidden states， 其中logits形状为<code>torch.Size([1, 3])</code>, 其中的3对应的是类别的数量。当训练时，第一项为loss。</p>
<p><strong>模型的构建</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> XLNetConfig, XLNetModel, XLNetTokenizer, XLNetForSequenceClassification</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 定义路径，初始化tokenizer</span></span><br><span class="line">XLN_PATH = <span class="string">r"D:\transformr_files\XLNetLMHeadModel"</span></span><br><span class="line">tokenizer = XLNetTokenizer.from_pretrained(XLN_PATH)</span><br><span class="line"><span class="comment"># 加载配置</span></span><br><span class="line">model_config = XLNetConfig.from_pretrained(XLN_PATH)</span><br><span class="line"><span class="comment"># 设定类别数为3</span></span><br><span class="line">model_config.num_labels = <span class="number">3</span></span><br><span class="line"><span class="comment"># 直接从xlnet的config新建XLNetForSequenceClassification(和上一节方法等效)</span></span><br><span class="line">cls_model = XLNetForSequenceClassification.from_pretrained(XLN_PATH, config=model_config)</span><br></pre></td></tr></table></figure>
<p><strong>利用模型进行运算：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定模式</span></span><br><span class="line">model.eval()</span><br><span class="line">token_codes = tokenizer.encode_plus(<span class="string">"i like you, what about you"</span>)</span><br><span class="line"><span class="comment"># encode_plus结果为字典形式</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    outputs = cls_model(input_ids=torch.tensor([token_codes[<span class="string">'input_ids'</span>]]),token_type_ids = torch.tensor([token_codes[<span class="string">'token_type_ids'</span>]]))</span><br><span class="line"><span class="comment"># outputs[0]为logits，outputs[1]为hidden</span></span><br></pre></td></tr></table></figure>
<p>输出的转化可直接通过numpy的argmax函数实现。</p>
<h3 id="其他的任务，将继续更新"><a href="#其他的任务，将继续更新" class="headerlink" title="其他的任务，将继续更新"></a>其他的任务，将继续更新</h3><p>其他的模型和之前的两个大致是相同的，你可以自己发挥。我会继续在相关的库上进行实验，如果发现用法不一样的情况，将会添加在这里。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文章主要对HuggingFace库进行了简要介绍。具体安装等过程请参见官方<a href="https://github.com/huggingface/transformers" target="_blank" rel="noopener">github仓库</a>。</p>
<p>本文主要参考于<a href="https://huggingface.co/transformers/installation.html#" target="_blank" rel="noopener">官方文档</a></p>
<p>同时，在模型的理解过程中参考了一些kaggle上的notebooks, <a href="https://www.kaggle.com/abhishek/bert-base-uncased-using-pytorch" target="_blank" rel="noopener">主要是这一篇</a>，作者是<a href="https://www.kaggle.com/abhishek" target="_blank" rel="noopener">Abhishek Thakur</a></p>
<h1 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h1><ul>
<li>2020/5/4 <ul>
<li>添加不同模型需要的分词格式变化</li>
<li>增改论文链接</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/10/04/Forest_Cover_Type_Prediction-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/04/Forest_Cover_Type_Prediction-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/" class="post-title-link" itemprop="url">Prediction-特征选择</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-04 13:15:25" itemprop="dateCreated datePublished" datetime="2020-10-04T13:15:25+08:00">2020-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-05 15:02:18" itemprop="dateModified" datetime="2020-10-05T15:02:18+08:00">2020-10-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ml-kaggle/" itemprop="url" rel="index"><span itemprop="name">ml-kaggle</span></a>
                </span>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>data: <a href="https://www.kaggle.com/c/forest-cover-type-prediction/data" target="_blank" rel="noopener">https://www.kaggle.com/c/forest-cover-type-prediction/data</a></p>
<p>notebook: <a href="https://www.kaggle.com/sharmasanthosh/exploratory-study-on-feature-selection" target="_blank" rel="noopener">https://www.kaggle.com/sharmasanthosh/exploratory-study-on-feature-selection</a></p>
<h2 id="Data-statistics"><a href="#Data-statistics" class="headerlink" title="Data statistics"></a>Data statistics</h2><ul>
<li><p>Shape</p>
</li>
<li><p>Datatypes</p>
</li>
<li><p>Description</p>
<p>使用print(dataset.describe())命令对数据进行分析，主要分析</p>
<p><strong>count</strong>:是否有数据缺失，需不需要补全，</p>
<p><strong>min</strong>是否存在负值，</p>
<p>编码是怎样的，如果是独热编码，可以转换成原编码以进行统计。</p>
<p><strong>std</strong>：是否存在常数项，如果存在可以被删除。</p>
<p><strong>mean</strong>: 数值的大小是否一致，如果不一致则需要进行归一化处理。</p>
</li>
<li><p>Skew </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dataset.skew())</span><br></pre></td></tr></table></figure>
<p>数据的偏度，计算数据是左偏的还是右偏的</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Relationship_between_mean_and_median_under_different_skewness.png" alt="img"></p>
</li>
<li><p>Class distribution</p>
<p>计算类别分布</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataset.groupby(<span class="string">'Cover_Type'</span>).size()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Data-Interaction"><a href="#Data-Interaction" class="headerlink" title="Data Interaction"></a>Data Interaction</h2><ul>
<li><p>Correlation</p>
<p>相关系数需要连续数据，因此使用类别编码的将无法使用</p>
</li>
<li><p>Scatter plot</p>
</li>
</ul>
<h2 id="Data-Visualization"><a href="#Data-Visualization" class="headerlink" title="Data Visualization"></a>Data Visualization</h2><ul>
<li>Box and density plots</li>
<li>Grouping of one hot encoded attributes</li>
</ul>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABa8AAAJNCAYAAAA21omXAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjEsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+j8jraAAAgAElEQVR4nOzdfZDdVZ3n8c8hDUYlIg8JDwlMooUSBAwkgBoqZEAeZFVAUIOwoECxYykDO8quLjPO6FYcSmVKK66WzAiCzBKo+ACiKBokGePuhACxjLKopSy2IsTMUCBKSNqzf3DJJhCghe77O51+vaq6+v5O/+79fUP517uO55ZaawAAAAAAoCXbdT0AAAAAAAA8mXgNAAAAAEBzxGsAAAAAAJojXgMAAAAA0BzxGgAAAACA5gx0PcBo2W233er06dO7HgMAAAAAgGdw++23/7bWOvnJ69tsvJ4+fXpWrVrV9RgAAAAAADyDUsr/3dq6Y0MAAAAAAGiOeA0AAAAAQHPEawAAAAAAmrPNnnm9NRs2bMjg4GAeffTRrkfpu4kTJ2batGnZfvvtux4FAAAAAOBZjat4PTg4mEmTJmX69OkppXQ9Tt/UWrNu3boMDg5mxowZXY8DAAAAAPCsxtWxIY8++mh23XXXcRWuk6SUkl133XVc7jgHAAAAAMamcRWvk4y7cP2E8frvBgAAAADGpnEXrwEAAAAAaJ94DQAAAABAc8Z9vP7Nb36TBQsW5OUvf3n233//nHDCCfnJT37Sl2evW7cus2bNyqxZs7LHHntk6tSpm64fe+yxvswAAAAAANCiga4H6FKtNSeffHLOOuusLF68OEmyevXq3H///XnFK14xos8aGhrKhAkTtljbdddds3r16iTJ3/3d32XHHXfM+9///hF9LgAAAADAWDSud15/97vfzfbbb5+/+Iu/2LQ2a9asHHHEEbnoootywAEH5MADD8y1116bJHn729+eb3zjG5vufec735kvfelLGRoaykUXXZRDDz00Bx10UD73uc8lSW699db8+Z//ed7xjnfkwAMPHNZMDz/8cGbMmJENGzYkSR566KFMnz49GzZsyPz583PhhRfmda97XQ444ICsXLkySfLII4/k7LPPzqGHHpqDDz44119//Yj89wEAAAAA6Mq43nm9Zs2azJ49+ynrX/7yl7N69er84Ac/yG9/+9sceuihmTdvXhYsWJBrr702J5xwQh577LEsXbo0n/3sZ/P5z38+O+20U2677basX78+c+fOzbHHHpskWblyZdasWZMZM2YMa6ZJkyZl/vz5+frXv56TTjopixcvzimnnJLtt98+yeOh+vvf/36WL1+es88+O2vWrMnChQtz1FFH5fLLL8+DDz6Yww47LK9//evz4he/eOT+YwEAAAAA9NG43nn9dL73ve/ltNNOy4QJE7L77rvnyCOPzG233ZY3vOENueWWW7J+/frcdNNNmTdvXl74whfm5ptvzlVXXZVZs2bl8MMPz7p16/LTn/40SXLYYYcNO1w/4dxzz80VV1yRJLniiivyrne9a9PfTjvttCTJvHnz8tBDD+XBBx/MzTffnEsuuSSzZs3K/Pnz8+ijj+bee+8dof8aAAAAAAD9N653Xr/qVa/KkiVLnrJea93q/RMnTsz8+fPzrW99K9dee+2mkFxrzaJFi3Lcccdtcf+tt976nHY/z507N/fcc0+WLVuWoaGhHHDAAZv+VkrZ4t5SSmqt+dKXvpRXvvKVf/KzAAAAAABaNK53Xh911FFZv359/vEf/3HT2m233Zadd9451157bYaGhrJ27dosX748hx12WJJkwYIFueKKK/Iv//Ivm2L1cccdl89+9rObzqn+yU9+kkceeeR5zXbmmWfmtNNO22LXdZJN529/73vfy0477ZSddtopxx13XBYtWrQput95553P69kAAAAAAF0b1zuvSyn5yle+kgsvvDCXXHJJJk6cmOnTp+eTn/xkfve73+XVr351Sin52Mc+lj322CNJcuyxx+bMM8/Mm9/85uywww5JHj/m45577skhhxySWmsmT56cr371q89rttNPPz1//dd/vWl39xN23nnnvO51r8tDDz2Uyy+/PEnyN3/zN7nwwgtz0EEHpdaa6dOn58Ybb3xezwcAAAAA6FJ5uiMyxro5c+bUVatWbbF21113ZebMmR1N9KdZsmRJrr/++nzxi1/ctDZ//vx84hOfyJw5c57TZ46lfz8AAAAAMD6UUm6vtT4leo7rndetOv/883PTTTflG9/4RtejAAAAAAB0Qrzuk3Xr1uXoo49+yvrSpUuz6667brG2aNGirX7GrbfeOhqjAQAAAAA0R7zuk1133TWrV6/uegwAAAAAgDFhu64H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K1eu7HgiAAAAAIDRJ1437JFHHsnDDz+86fXNN9+cAw44oOOpAAAAAABGn2NDhum9l76p78+8//77c/LJJydJNm7cmHe84x05/vjj+z4HAAAAAEC/idcNe9nLXpYf/OAHXY8BAAAAANB3jg0BAAAAAKA54jUAAAAAAM0RrwEAAAAAaI54DQAAAABAc8RrAAAAAACaI14DAAAAANCcga4HGCsWnnHqiH7exVcvGdZ9Dz74YM4999ysWbMmpZRcfvnlee1rXzuiswAAAAAAtEa8btwFF1yQ448/PkuWLMljjz2W3//+912PBAAAAAAw6sTrhj300ENZvnx5vvCFLyRJdthhh+ywww7dDgUAAAAA0AfOvG7Yz3/+80yePDnvete7cvDBB+fcc8/NI4880vVYAAAAAACjTrxu2MaNG3PHHXfk3e9+d+688868+MUvziWXXNL1WAAAAAAAo068bti0adMybdq0HH744UmSU089NXfccUfHUwEAAAAAjD7xumF77LFH9t5779x9991JkqVLl2b//ffveCoAAAAAgNHnCxuH6eKrl3Ty3EWLFuX000/PY489lpe97GW54oorOpkDAAAAAKCfxOvGzZo1K6tWrep6DAAAAACAvnJsCAAAAAAAzRGvAQAAAABojngNAAAAAEBzxGsAAAAAAJojXgMAAAAA0BzxGgAAAACA5gx0PcBYcdfCW0b082ZefNSz3nP33Xfn7W9/+6brn//85/nIRz6SCy+8cERnAQAAAABojXjdsFe+8pVZvXp1kmRoaChTp07NySef3PFUAAAAAACjz7EhY8TSpUvz8pe/PH/2Z3/W9SgAAAAAAKNOvB4jFi9enNNOO63rMQAAAAAA+kK8HgMee+yx3HDDDXnrW9/a9SgAAAAAAH0hXo8BN910Uw455JDsvvvuXY8CAAAAANAX4vUYcM011zgyBAAAAAAYVwa6HmCsmHnxUZ089/e//32+/e1v53Of+1wnzwcAAAAA6IJ43bgXvehFWbduXddjAAAAAAD0lWNDAAAAAABojngNAAAAAEBzxl28rrV2PUInxuu/GwAAAAAYm8ZVvJ44cWLWrVs37kJurTXr1q3LxIkTux4FAAAAAGBYxtUXNk6bNi2Dg4NZu3Zt16P03cSJEzNt2rSuxwAAAAAAGJZxFa+33377zJgxo+sxAAAAAAB4FuPq2BAA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" alt="img"></p>
<h2 id="Data-Cleaning"><a href="#Data-Cleaning" class="headerlink" title="Data Cleaning"></a>Data Cleaning</h2><ul>
<li>Remove unnecessary columns</li>
</ul>
<h2 id="Data-Preparation"><a href="#Data-Preparation" class="headerlink" title="Data Preparation"></a>Data Preparation</h2><ul>
<li>Original</li>
<li>Delete rows or impute values in case of missing</li>
<li>StandardScaler</li>
<li>MinMaxScaler</li>
<li>Normalizer</li>
</ul>
<h2 id="Feature-selection"><a href="#Feature-selection" class="headerlink" title="Feature selection"></a>Feature selection</h2><ul>
<li>ExtraTreesClassifier</li>
<li>GradientBoostingClassifier</li>
<li>RandomForestClassifier</li>
<li>XGBClassifier</li>
<li>RFE</li>
<li>SelectPercentile</li>
<li>PCA</li>
<li>PCA + SelectPercentile</li>
<li>Feature Engineering</li>
</ul>
<h2 id="Evaluation-prediction-and-analysis"><a href="#Evaluation-prediction-and-analysis" class="headerlink" title="Evaluation, prediction, and analysis"></a>Evaluation, prediction, and analysis</h2><ul>
<li>LDA (Linear algo)</li>
<li>LR (Linear algo)</li>
<li>KNN (Non-linear algo)</li>
<li>CART (Non-linear algo)</li>
<li>Naive Bayes (Non-linear algo)</li>
<li>SVC (Non-linear algo)</li>
<li>Bagged Decision Trees (Bagging)</li>
<li>Random Forest (Bagging)</li>
<li>Extra Trees (Bagging)</li>
<li>AdaBoost (Boosting)</li>
<li>Stochastic Gradient Boosting (Boosting)</li>
<li>Voting Classifier (Voting)</li>
<li>MLP (Deep Learning)</li>
<li>XGBoost</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/10/01/Titanic%E4%B8%AD%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%9A%84%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/01/Titanic%E4%B8%AD%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%9A%84%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Titanic中特征选择的技巧</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-01 17:18:20" itemprop="dateCreated datePublished" datetime="2020-10-01T17:18:20+08:00">2020-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-03 12:57:11" itemprop="dateModified" datetime="2020-10-03T12:57:11+08:00">2020-10-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ml-kaggle/" itemprop="url" rel="index"><span itemprop="name">ml-kaggle</span></a>
                </span>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>data: <a href="https://www.kaggle.com/c/titanic/data" target="_blank" rel="noopener">https://www.kaggle.com/c/titanic/data</a></p>
<p>notebook: <a href="https://www.kaggle.com/namylase/titanic-eda-full-pipeline-ensemble" target="_blank" rel="noopener">https://www.kaggle.com/namylase/titanic-eda-full-pipeline-ensemble</a></p>
<h3 id="预处理-增加特征"><a href="#预处理-增加特征" class="headerlink" title="预处理 增加特征"></a>预处理 增加特征</h3><p>添加名字长度，</p>
<p>是否有舱位，</p>
<p>FamilySize为双亲加伴侣的数目+1，</p>
<p>当FamilySize大于1时IsAlone为0，否则为1，</p>
<p>Embarked填充空值为‘S’</p>
<p>Fare填充空值为中位数</p>
<p>train中CategoricalFare将Fare利用pd.qcut函数由大到小分为4个类别。</p>
<p>train中CategoricalAge利用pd.cut()将年龄分为5个类别。</p>
<p>Title是名称的前缀</p>
<p>Sex由female,male转化成类别编码1，2，title、Embarked也作相同操作。</p>
<p>Age，Fare根据范围也转化成类别型表示。</p>
<h3 id="预处理-drop特征"><a href="#预处理-drop特征" class="headerlink" title="预处理 drop特征"></a>预处理 drop特征</h3><p>train、test去除[‘PassengerId’, ‘Name’, ‘Ticket’, ‘Cabin’, ‘SibSp’]特征</p>
<p>train中还去除[‘CategoricalAge’, ‘CategoricalFare’]</p>
<h3 id="特征可视化"><a href="#特征可视化" class="headerlink" title="特征可视化"></a>特征可视化</h3><p>使用Seaborn热图进行特征间相关性的可视化，最终得出的结论是所保留的特征相关性都比较低，也就是没有太多冗余的特征。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><ol>
<li>Random Forest classifier</li>
<li>Extra Trees classifier</li>
<li>AdaBoost classifer</li>
<li>Gradient Boosting classifer</li>
<li>Support Vector Machine</li>
</ol>
<p>训练时使用Out-of-Fold Predictions的方法进行。</p>
<h3 id="Out-of-Fold-Predictions"><a href="#Out-of-Fold-Predictions" class="headerlink" title="Out-of-Fold Predictions"></a><a href="https://machinelearningmastery.com/out-of-fold-predictions-in-machine-learning/" target="_blank" rel="noopener">Out-of-Fold Predictions</a></h3><p>通常机器学习算法训练时是通过重采样方法（K-fold）等来进行模型的评价的。在k折交叉验证中，预测是利用训练中没有使用的数据进行的。Out-of-Fold预测主要有两种作用：</p>
<ul>
<li>估测模型在将来未知数据上的表现</li>
<li>拟合集成模型</li>
</ul>
<p>估测模型在将来未知数据上的表现主要有两种方法：</p>
<ol>
<li>在每折运算过后，计算模型的得分，最后进行平均。</li>
<li>在K折交叉运算中，每个训练样本都在测试集中出现恰好一次。将对其进行预测的结果收集起来，和真实的样本标签进行对比，得分即作为模型的表现，这个表现是通过整个训练数据集计算得到的。</li>
</ol>
<p>拟合集成模型是Out-of-Fold的另一项重要应用。在K折交叉验证中，会生成K个基本模型。除此之外，一个更高阶的meta-model会通过<strong>基本模型的预测</strong>训练出来。这个模型的作用是学习如何更好地结合基本模型的方法。</p>
<ul>
<li><strong>Meta-Model Input</strong>: Input portion of a given sample concatenated with the predictions made by each base model.</li>
<li><strong>Meta-Model Output</strong>: Output portion of a given sample.</li>
</ul>
<p>得到Meta模型之后，在全部的训练数据集上训练每个基本模型，并用于之后的预测。</p>
<p>这个过程被称为stacked generalization。这里使用线性权值的方法得到Meta model，这个过程也被称为<strong>blending</strong>。</p>
<h2 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h2><p>使用5折交叉验证进行训练，对于每一个基本模型，在每一折训练后，用out-of-fold测试集进行测试，并将此模型在总体测试集上进行预测，将预测结果存在数组第二维中，最终测试结果在第一维取平均值，得到最终结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (train_index, test_index) <span class="keyword">in</span> enumerate(kf):</span><br><span class="line">    x_tr = x_train[train_index]</span><br><span class="line">    y_tr = y_train[train_index]</span><br><span class="line">    x_te = x_train[test_index]</span><br><span class="line"></span><br><span class="line">    clf.train(x_tr, y_tr)</span><br><span class="line"></span><br><span class="line">    oof_train[test_index] = clf.predict(x_te)</span><br><span class="line">    oof_test_skf[i, :] = clf.predict(x_test)</span><br><span class="line"><span class="comment"># 取平均、返回结果</span></span><br><span class="line">oof_test[:] = oof_test_skf.mean(axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> oof_train.reshape(<span class="number">-1</span>, <span class="number">1</span>), oof_test.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="特征重要性可视化"><a href="#特征重要性可视化" class="headerlink" title="特征重要性可视化"></a>特征重要性可视化</h3><p>将各特征在模型中的重要性提取出来，只有树类型的模型可以作此操作，也就是模型1—4。</p>
<h2 id="模型的集成"><a href="#模型的集成" class="headerlink" title="模型的集成"></a>模型的集成</h2><p>利用XGBClassifier对模型进行集成。首先将第一步得到的所有模型训练集预测结果连接起来，对XGBClassifier进行训练。然后把相同方法处理得到的测试集输入进行预测，得到最终的结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/09/30/Titanic%E5%88%A9%E7%94%A8%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E5%BE%97%E5%88%B0%E4%B8%8D%E9%94%99%E7%9A%84%E7%BB%93%E6%9E%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/30/Titanic%E5%88%A9%E7%94%A8%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E5%BE%97%E5%88%B0%E4%B8%8D%E9%94%99%E7%9A%84%E7%BB%93%E6%9E%9C/" class="post-title-link" itemprop="url">Titanic利用集成学习得到不错的结果</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-30 12:40:05" itemprop="dateCreated datePublished" datetime="2020-09-30T12:40:05+08:00">2020-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-01 17:20:22" itemprop="dateModified" datetime="2020-10-01T17:20:22+08:00">2020-10-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ml-kaggle/" itemprop="url" rel="index"><span itemprop="name">ml-kaggle</span></a>
                </span>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>data: <a href="https://www.kaggle.com/c/titanic/data" target="_blank" rel="noopener">https://www.kaggle.com/c/titanic/data</a></p>
<p>notebook: <a href="https://www.kaggle.com/namylase/titanic-eda-full-pipeline-ensemble" target="_blank" rel="noopener">https://www.kaggle.com/namylase/titanic-eda-full-pipeline-ensemble</a></p>
<h3 id="填充空值"><a href="#填充空值" class="headerlink" title="填充空值"></a>填充空值</h3><p>将Embarked补充为出现次数最多的值</p>
<p>将Fare的空值补充为相同舱位Fare的中位数</p>
<p>将Age的空值补充为相同舱位Age的中位数</p>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>建立家庭特征，为姐妹和伴侣的集合</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>df[‘SibSp’]+df[‘Parch’]+1</th>
<th>Family</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>[2,4]</td>
<td>2</td>
</tr>
<tr>
<td>[5,6]</td>
<td>3</td>
</tr>
<tr>
<td>else</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>去除SibSp， Parch， PassengerId等特征，同时也去除目标值Survived。</p>
<p>Ticket转换成Ticket_freq， 并去除Ticket特征。</p>
<p>Cabin提取首字母(代表舱位号)，并进行聚类，分为ABCT， DE, FG。</p>
<p>提取名称中带的Mrs等前缀，作为新的Name特征。</p>
<p>将Age, Fare 装箱，即将连续值映射成离散值Age_cat， Fare_cat， 并去除Age和Fare特征</p>
<p>最终将属性值分类如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">attribs=[<span class="string">'Pclass'</span>,<span class="string">'Name'</span>,<span class="string">'Sex'</span>,<span class="string">'Age'</span>,<span class="string">'Ticket'</span>,<span class="string">'Fare'</span>,<span class="string">'Cabin'</span>,<span class="string">'Embarked'</span>,<span class="string">'SibSp'</span>,<span class="string">'Parch'</span>]</span><br><span class="line">num_attribs=[<span class="string">'Pclass'</span>,<span class="string">'Age_cat'</span>,<span class="string">'Fare_cat'</span>,<span class="string">"Ticket_freq"</span>]</span><br><span class="line">cat_attribs=[<span class="string">'Name'</span>,<span class="string">'Sex'</span>,<span class="string">'Cabin'</span>,<span class="string">'Embarked'</span>,<span class="string">'Family'</span>]</span><br></pre></td></tr></table></figure>
<p>对于其中的类别属性cat_attribs，使用DataFrame的get_dummies()方法得到One-Hot编码。得到最终的属性集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Index([&#39;Pclass&#39;, &#39;Ticket_freq&#39;, &#39;Age_cat&#39;, &#39;Fare_cat&#39;, &#39;Name_Miss&#39;, &#39;Name_Mr&#39;,</span><br><span class="line">       &#39;Name_Mrs&#39;, &#39;Name_etc&#39;, &#39;Sex_female&#39;, &#39;Sex_male&#39;, &#39;Cabin_ABCT&#39;,</span><br><span class="line">       &#39;Cabin_DE&#39;, &#39;Cabin_FG&#39;, &#39;Cabin_X&#39;, &#39;Embarked_C&#39;, &#39;Embarked_Q&#39;,</span><br><span class="line">       &#39;Embarked_S&#39;, &#39;Family_1&#39;, &#39;Family_2&#39;, &#39;Family_3&#39;, &#39;Family_4&#39;],</span><br><span class="line">      dtype&#x3D;&#39;object&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>将DataFrame通过to_numpy()转换为矩阵</p>
<p><a href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" target="_blank" rel="noopener">Choosing the right estimator</a></p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>作者使用了多个模型进行集成学习的方式。以SVC为例进行介绍：</p>
<p>首先使用cross_val_score对模型进行大致的估计</p>
<p>使用grid_search()确定参数C的大致范围，C是正则化参数，最终得到最好的模型</p>
<h2 id="模型的集成"><a href="#模型的集成" class="headerlink" title="模型的集成"></a>模型的集成</h2><p>使用VotingClassifier的hard模式和soft模式还有StackingClassifier进行集成，得到最终的集成分类器。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VotingClassifier__hard&#x2F;StackingClassifier：0.83613917</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/09/30/Optimizer%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/30/Optimizer%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Optimizer详解</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-30 12:37:13" itemprop="dateCreated datePublished" datetime="2020-09-30T12:37:13+08:00">2020-09-30</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/06/06/adaboost/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/adaboost/" class="post-title-link" itemprop="url">Adaboost</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-06 08:44:46 / 修改时间：08:46:24" itemprop="dateCreated datePublished" datetime="2020-06-06T08:44:46+08:00">2020-06-06</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AdaBoost-Implementation-and-intuition"><a href="#AdaBoost-Implementation-and-intuition" class="headerlink" title="AdaBoost: Implementation and intuition"></a>AdaBoost: Implementation and intuition</h1><p>Xavier Bourret SicotteTue 10 July 2018</p>
<p>Category: <a href="https://xavierbourretsicotte.github.io/category/machine-learning.html" target="_blank" rel="noopener">Machine Learning</a></p>
<h1 id="Implementing-AdaBoost-using-Logistic-regression-weak-classifiers"><a href="#Implementing-AdaBoost-using-Logistic-regression-weak-classifiers" class="headerlink" title="Implementing AdaBoost using Logistic regression weak classifiers"></a>Implementing AdaBoost using Logistic regression weak classifiers</h1><p>This notebook explores the well known <strong>AdaBoost M1</strong> algorithm which combines several weak classifiers to create a better overall classifier. The notebook consists of three main sections:</p>
<ol>
<li>A review of the Adaboost M1 algorithm and an intuitive visualization of its inner workings</li>
<li>An implementation from scratch in Python, using an Sklearn decision tree stump as the weak classifier</li>
<li>A discussion on the trade-off between the Learning rate and Number of weak classifiers parameters</li>
</ol>
<p>This notebook was used as a basis for the following answers on stats.stackexchange</p>
<ul>
<li><a href="https://stats.stackexchange.com/questions/82323/shrinkage-parameter-in-adaboost/355632#355632" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/82323/shrinkage-parameter-in-adaboost/355632#355632</a></li>
<li><a href="https://stats.stackexchange.com/questions/164233/intuitive-explanations-of-differences-between-gradient-boosting-trees-gbm-ad/355618#355618" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/164233/intuitive-explanations-of-differences-between-gradient-boosting-trees-gbm-ad/355618#355618</a></li>
<li><a href="https://stats.stackexchange.com/questions/274563/adaboost-best-weak-learner-with-0-5-error/355604#355604" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/274563/adaboost-best-weak-learner-with-0-5-error/355604#355604</a></li>
</ul>
<p>This implementation relies on a simple decision tree stum with maximum depth = 1 and 2 leaf nodes. Of interest is the plot of decision boundaries for different weak learners inside the AdaBoost combination, together with their respective sample weights.</p>
<h1 id="An-intuitive-explanation-of-AdaBoost-algorithn"><a href="#An-intuitive-explanation-of-AdaBoost-algorithn" class="headerlink" title="An intuitive explanation of AdaBoost algorithn"></a>An intuitive explanation of AdaBoost algorithn</h1><h3 id="AdaBoost-recap"><a href="#AdaBoost-recap" class="headerlink" title="AdaBoost recap"></a>AdaBoost recap</h3><p>Let $G_m(x)  m = 1,2,…,M$ be the sequence of weak classifiers, our objective is to build the following:</p>
<script type="math/tex; mode=display">G(x) = \text{sign} \left( \alpha_1 G_1(x) + \alpha_2 G_2(x) + ... \alpha_M G_M(x)\right) = \text{sign} \left( \sum_{m = 1}^M \alpha_m G_m(x)\right)</script><ul>
<li>The final prediction is a combination of the predictions from all classifiers through a weighted majority vote</li>
<li>The coefficients $\alpha_m$ are computed by the boosting algorithm, and weight the contribution of each respective $G_m(x)$. The effect is to give higher influence to the more accurate classifiers in the sequence.</li>
<li>At each <em>boosting</em> step, the data is modified by applying weights $w_1, w_2,…,w_N$ to each training observation. At step $m$ the observations that were <em>misclassified</em> previously have their weights increased</li>
<li>Note that at the first step $m=1$ the weights are initialized uniformly $w_i = 1 / N$</li>
</ul>
<hr>
<h3 id="The-algorith-as-summarised-on-page-339-of-Elements-of-Statistical-Learning"><a href="#The-algorith-as-summarised-on-page-339-of-Elements-of-Statistical-Learning" class="headerlink" title="The algorith, as summarised on page 339 of Elements of Statistical Learning"></a>The algorith, as summarised on page 339 of Elements of Statistical Learning</h3><ol>
<li>Initialize the obervation weights $w_i = 1/N$</li>
<li>For $m = 1,2,…,M$<ul>
<li>Compute the weighted error $ Err_m = \frac{\sum_{i-1}^N w_i \mathcal{I}(y^{(i)} \neq G_m(x^{(i)}) )}{\sum_{i=1}^N w_i}$</li>
<li>Compute coefficient $\alpha_m = \log \left( \frac{1 - err_m}{err_m}\right)$</li>
<li>Set data weights $w_i \leftarrow w_i \exp[ \alpha_m  \mathcal{I}(y^{(i)} \neq G_m(x^{(i)}))]$</li>
</ul>
</li>
<li>Output $G(x) = \text{sign} \left[ \sum_{m=1}^M \alpha_m G_m(x)\right]$</li>
</ol>
<h3 id="AdaBoost-on-a-toy-example"><a href="#AdaBoost-on-a-toy-example" class="headerlink" title="AdaBoost on a toy example"></a>AdaBoost on a toy example</h3><p>Consider the toy data set on which I have applied AdaBoost with the following settings: Number of iterations $M = 10$, weak classifier = Decision Tree of depth 1 and 2 leaf nodes. The boundary between red and blue data points is clearly non linear, yet the algorithm does pretty well.</p>
<p><a href="https://i.stack.imgur.com/lf7Xk.png" target="_blank" rel="noopener"><img src="https://i.stack.imgur.com/lf7Xk.png" alt="enter image description here"></a></p>
<h2 id="Visualizing-the-sequence-of-weak-learners-and-the-sample-weights"><a href="#Visualizing-the-sequence-of-weak-learners-and-the-sample-weights" class="headerlink" title="Visualizing the sequence of weak learners and the sample weights"></a>Visualizing the sequence of weak learners and the sample weights</h2><p>The first 6 weak learners $m = 1,2…,6$ are shown below. The scatter points are scaled according to their respective sample weight at each iteration</p>
<p><a href="https://i.stack.imgur.com/WHUgY.png" target="_blank" rel="noopener"><img src="https://i.stack.imgur.com/WHUgY.png" alt="enter image description here"></a></p>
<p><strong>First iteration:</strong></p>
<ul>
<li>The decision boundary is very simple (linear) since these are wea learners</li>
<li>All points are of the same size, as expected</li>
<li>6 blue points are in the red region and are misclassified</li>
</ul>
<p><strong>Second iteration:</strong></p>
<ul>
<li>The linear decision boundary has changed</li>
<li>The previously misclassified blue points are now larger (greater sample_weight) and have influenced the decision boundary</li>
<li>9 blue points are now misclassified</li>
</ul>
<p><strong>Final result</strong> after 10 iterations</p>
<p>All classifiers have a linear decision boundary, at different positions. The resulting coefficients of the first 6 iterations $\alpha_m$ are :</p>
<p>([1.041, 0.875, 0.837, 0.781, 1.04 , 0.938…</p>
<p>As expected, the first iteration has largest coefficient as it is the one with the fewest mis-classifications.</p>
<h3 id="Next-steps"><a href="#Next-steps" class="headerlink" title="Next steps"></a>Next steps</h3><p>An intuitive explanation of gradient boosting - to be completed</p>
<h3 id="Sources"><a href="#Sources" class="headerlink" title="Sources:"></a>Sources:</h3><ul>
<li><a href="https://www.cs.cmu.edu/~aarti/Class/10701/slides/Lecture10.pdf" target="_blank" rel="noopener">https://www.cs.cmu.edu/~aarti/Class/10701/slides/Lecture10.pdf</a></li>
</ul>
<h1 id="Implementing-AdaBoost-M1-from-scratch"><a href="#Implementing-AdaBoost-M1-from-scratch" class="headerlink" title="Implementing AdaBoost M1 from scratch"></a>Implementing AdaBoost M1 from scratch</h1><h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from matplotlib.colors import ListedColormap</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">sns.set_style(&#39;white&#39;)</span><br><span class="line"></span><br><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line">from sklearn.ensemble import AdaBoostClassifier</span><br></pre></td></tr></table></figure>
<h3 id="Dataset-and-Utility-plotting-function"><a href="#Dataset-and-Utility-plotting-function" class="headerlink" title="Dataset and Utility plotting function"></a>Dataset and Utility plotting function</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#Toy Dataset</span><br><span class="line">x1 &#x3D; np.array([.1,.2,.4,.8, .8, .05,.08,.12,.33,.55,.66,.77,.88,.2,.3,.4,.5,.6,.25,.3,.5,.7,.6])</span><br><span class="line">x2 &#x3D; np.array([.2,.65,.7,.6, .3,.1,.4,.66,.77,.65,.68,.55,.44,.1,.3,.4,.3,.15,.15,.5,.55,.2,.4])</span><br><span class="line">y &#x3D; np.array([1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1])</span><br><span class="line">X &#x3D; np.vstack((x1,x2)).T</span><br><span class="line"></span><br><span class="line">def plot_decision_boundary(classifier, X, y, N &#x3D; 10, scatter_weights &#x3D; np.ones(len(y)) , ax &#x3D; None ):</span><br><span class="line">    &#39;&#39;&#39;Utility function to plot decision boundary and scatter plot of data&#39;&#39;&#39;</span><br><span class="line">    x_min, x_max &#x3D; X[:, 0].min() - .1, X[:, 0].max() + .1</span><br><span class="line">    y_min, y_max &#x3D; X[:, 1].min() - .1, X[:, 1].max() + .1</span><br><span class="line">    xx, yy &#x3D; np.meshgrid( np.linspace(x_min, x_max, N), np.linspace(y_min, y_max, N))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    #Check what methods are available</span><br><span class="line">    if hasattr(classifier, &quot;decision_function&quot;):</span><br><span class="line">        zz &#x3D; np.array( [classifier.decision_function(np.array([xi,yi]).reshape(1,-1)) for  xi, yi in zip(np.ravel(xx), np.ravel(yy)) ] )</span><br><span class="line">    elif hasattr(classifier, &quot;predict_proba&quot;):</span><br><span class="line">        zz &#x3D; np.array( [classifier.predict_proba(np.array([xi,yi]).reshape(1,-1))[:,1] for  xi, yi in zip(np.ravel(xx), np.ravel(yy)) ] )</span><br><span class="line">    else :</span><br><span class="line">        zz &#x3D; np.array( [classifier(np.array([xi,yi]).reshape(1,-1)) for  xi, yi in zip(np.ravel(xx), np.ravel(yy)) ] )</span><br><span class="line">            </span><br><span class="line">    # reshape result and plot</span><br><span class="line">    Z &#x3D; zz.reshape(xx.shape)</span><br><span class="line">    cm_bright &#x3D; ListedColormap([&#39;#FF0000&#39;, &#39;#0000FF&#39;])</span><br><span class="line">    </span><br><span class="line">    #Get current axis and plot</span><br><span class="line">    if ax is None:</span><br><span class="line">        ax &#x3D; plt.gca()</span><br><span class="line">    ax.contourf(xx, yy, Z, 2, cmap&#x3D;&#39;RdBu&#39;, alpha&#x3D;.5)</span><br><span class="line">    ax.contour(xx, yy, Z,  2, cmap&#x3D;&#39;RdBu&#39;)</span><br><span class="line">    ax.scatter(X[:,0],X[:,1], c &#x3D; y, cmap &#x3D; cm_bright, s &#x3D; scatter_weights * 40)</span><br><span class="line">    ax.set_xlabel(&#39;$X_1$&#39;)</span><br><span class="line">    ax.set_ylabel(&#39;$X_2$&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="Sklearn-AdaBoost-and-decision-boundary"><a href="#Sklearn-AdaBoost-and-decision-boundary" class="headerlink" title="Sklearn AdaBoost and decision boundary"></a>Sklearn AdaBoost and decision boundary</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boost &#x3D; AdaBoostClassifier( base_estimator &#x3D; DecisionTreeClassifier(max_depth &#x3D; 1, max_leaf_nodes&#x3D;2), </span><br><span class="line">                            algorithm &#x3D; &#39;SAMME&#39;,n_estimators&#x3D;10, learning_rate&#x3D;1.0)</span><br><span class="line">boost.fit(X,y)</span><br><span class="line">plot_decision_boundary(boost, X,y, N &#x3D; 50)#, weights)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">boost.score(X,y)</span><br></pre></td></tr></table></figure>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYAAAAEGCAYAAABsLkJ6AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDIuMS4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvNQv5yAAAIABJREFUeJzt3XmUHWWB9/Fv1V369pq900nYEoFHICQBAyQhCIyyRURGQUEWRUAZUJaMQlxeUF4HX2AiKIqIiCyjo6AGUEJwYdgS4kBIIAg8ECAhezrpTu99t6r3j9uBm3Sns5Cu6tv1+5zDOblVN31/p0jX71bVU/U4vu8jIiLR44YdQEREwqECEBGJKBWAiEhEqQBERCJKBSAiElHxsAPsDGNMGXAEsBbIhxxHRKRUxIBRwPPW2vS2K0uiACjs/J8JO4SISIk6Bnh224WlUgBrAT5z+Q1UDR4edpbALFryKo/95Rke/OnXGTak+r3lg+IeSXIk2hpDTCfStzqqasnh0pJ9/16lx59awo0/n8NlXzmbIYNqQkxXGlo3b+QPP/4WdO1Dt1UqBZAHqBo8nJphI8POEpiyqrXk3BQjRtZRO2zQe8uHJDzKyJFoTYaYTqRvtVePIodLU+b9AqgespKcm6Jq8Ahqhg4OMV3J6fHUuS4Ci4hElApARCSiVAAiIhGlAhARiSgVgIhIRKkAREQiSgUgIhJRKgARkYhSAYiIRJQKQEQkolQAIiIRFcizgIwxLnA7MBFIAxdZa5cVrf86cDbgATdYa+cEkUtEJMqCOgI4HUhZa6cCs4DZW1YYYwYDlwNTgROBWwPKJCISaUEVwHRgHoC1diEwuWhdG7ACqOz6zwsok4hIpAVVADVAU9HrvDGm+PTTSuBV4EXgxwFlEhGJtKAKoBmoLnrtWmtzXX8+hcKUZWOBfYDTjTFHBpRLRCSygiqA+cAMAGPMFGBp0bpGoANIW2s7gc2AZnoQEeljQc0INgc4wRizAHCAC4wxM4Fl1tpHjDEfBxYaYzwK81b+NaBcIiKRFUgBWGs94JJtFr9etP464Logskj/5Xnw2BMVPDS3iooKj3PPaOGISemwY4kMWKUyJ7AMcNksfPK80SxcVE5rm4vr+vzqvwdx5Zcbuf6ahrDjiQxIuhNY+oX7H6zhuRcKO38Az3No73C55edDeOX1ZMjpRAYmFYD0C3f/dw1t7d3/OWayDg88XBVCIpGBTwUg/UI25/S43PO2v05EPhgVgPQL53y6mfJU95vAy1M+p5/SGkIikYFPBSD9wkXnNHPAuAwV5e+XQGWFxxmfbOHIwzQSSKQvaBSQ9AsVFT4L/ryK+39fze8erqaywuPCs5v55EltODoDJNInVADSb6RSPhef28zF5zaHHUUkEnQKSEQkolQAIiIRpQIQEYkoFYCISESpAEREIkoFICISUSoAEZGIUgGIiESUCkAiI5+HNetidHTo1mIRCPBOYGOMC9wOTATSwEXW2mVd6yYBtxa9fQpwurV2XlD5ZGC7494arr1xOB2dDr4PZ53ewm031FNe7ocdTSQ0QT4K4nQgZa2d2jUx/GzgUwDW2iXAcQDGmDOBNdr5y55y7wPVXH39CNo73j/g/e1D1dQ3xHj43rUhJhMJV5CngKYD8wCstQuBydu+wRhTCXwPuDzAXDLAXXfTsK12/gCdaZe/P13BW8sTIaUSCV+QBVADNBW9zhtjtj0CuRB40Fq7MbhYMpB5Hqxa0/NOPpn0eX2ZCkCiK8gCaAaqiz/bWpvb5j3nAHcFF0kGOteF2uHb/jMryOYcxu2bDTjRwNLU7LK+PoavSyklKcgCmA/MAOi6BrC0eKUxZhBQZq1dGWAmiYBrvtqw1UQzAMmEx+GHpjnoABXA7lizLsbJZ41m1KHjGHfkfhwwZT/+8mRF2LFkFwVZAHOATmPMAuAW4CpjzExjzGld6w8ElgeYRyLi8oubuOLiRspTHjXVeVJlHsdO6+Che9aEHa0kZbMw/bS9+Z/5FWSyDum0y/KVCT5z4SgWvVwWdjzZBYGNArLWesAl2yx+vWj98xRGConsUY4D/3dWA9d8rZE33kpSV5tjdF0+7Fgl689/raShMUY+v/X9FJ2dDjfcOpQ/3K2RVaVCM4JJZFRV+hw+QfMLf1D/tGW0tXe/mc73HZa+lgwhkewu3QkcsnweNm+Mk+nU3alSGj60b5bKip6u+vrsP1bXVEqJjgBC9NQjg5l7/wiyGQcfmHxcM2deup5kmYZUSP/1rzNamXndcNraHXz//S8uFeU+sy5vCDGZ7CodAYRkwbxBPHJ3Le2tMbIZl1zG5YUna7j3xtFhRxPpVSrl8+ScVRx8YIbylEd1lcfgQXl+dtMGPjqlM+x4sgt0BBCSufcPJ5Peun9zGZfXFlXSsD7O0JE9j13fHa1tDv/1+xrm/2+KcftmufDzzeyz1577+RKM1Wtj/PI3Nbz5dpKjDu/kvDNbGFTj7fgv9gGzf5aX/udd3lqeoLXN4eADMyR0T13JUQGEIJ+HpoaeN30s7rNuZdkeK4BVa+JM/cTeNLe4tLW7JJMet/x8CA/+ci0nHde+Rz5D+t6TC8r51PmjyeUhnXZ5eF4V3791KM89upKx+4RX5h/aT+f8S5lOAYUgFoPKmp6HIeZzDsPrMnvss6749gg2bIzR1l74X53JuLR3uJz7b3Vk9btbEvJ5+PwldbS1u6S7jhrbO1waGmNc8o2RIaeTUqYCCMkJZ24iWbb14Xss7rGf6aB2rz2zZ/Y8ePTvld3Ga0Nhp7LghfI98jnSt15cWkZHD6PEPM/hqefK6dQIMtlNOgUUkn/5TCNtLXGefGgIsbhPLutw4MR2vnDNnr071d/eKWIHcroMUBJyue3v4H0fPYdHdpsKICSOA6ddUM+Jn9tE/ZoEg4bmqBm6Z+9OdV047uh2nni2YqvhelD49nj0ERqxUQomT+wk1sOxuuP4HHlYpya1kd2mU0AhS1V47L1/eo/v/Le47YZ6BlV7pLpON8ViHhXlHnfcvJ5USjuOUpBIwN23rqe83CMWK/x/LEsWhl/+7KYNIaeTUqYjgAHuwA9l+eczK/jZPYN4emE5H9o3y1cv3MzEQ/bchWbpe6ed3MbCuSu57a5BvPF2kqkf6eSyL23WM43kA1EBRMDIEXm++w3doVnqDjEZ7ri5PuwYMoDoFJCISESpAEREIkoFICISUSoAEYkUr+sR7GndQBfMRWBjjAvcDkwE0sBF1tplRetPAa7revkicJm1VmMURWSPenbuIP50T23hEeweTJrewlmXr6MsokOigzoCOB1IWWunArOA2VtWGGOqgZuBU621UyjMCzw8oFwiEhHPP1HDnDtH0t4SI5t2yWVdljxbzS+uHxN2tNAEVQDTgXkA1tqFwOSiddOApcBsY8wzwHprrca6icge9WhPj2DPurz9zwrWr4rmVJZBFUAN0FT0Om+M2XL6aThwPHANcApwpTHmwIByiUhENKzvecKCWNxn3QoVQF9qBqqLP9dau+VRZJuA562166y1rcDTwKSAcolIRNQM7fnph17eYcToaD4bPagCmA/MADDGTKFwymeLRcB4Y8zwrqOCKcCrAeUSkYg46ayeH8E+er9ORo9Nh5QqXEE9CmIOcIIxZgHgABcYY2YCy6y1jxhjvgk83vXeB6y1r/T0Q/7xwlKSlSuDSdwPvPyK7bbMAVzHhWgOWpCIcR2Hnv6xL1r8KiOGD9mln1W5F4w/oYql/6jGcX28nMPIfdJMO62RxS8NzF+ozpbeHwHj+CXwMHFjzH7AOytTHyHnpsKOE6hRo2r566++SVkiTkXcoSIOjuMQ72gilm4JO55In2lIDqOqsoJ8Pk9rzqEz77NidT1nfnU2m5vbwo5XEuJeJ3t3LgIYa61d3m194Ik+gEd+MYvaulFhxwhUdWU5FQmXyhjEYi6dnWmq0g2km5pIt3aEHU+kz1QO6iDuDSJTNpRBZQkqcjmSe4/gyd98j7X1jWHHKwmbNqzn/3ztgu2uL6kCGFFTQd3gyrBjBMYBUjGfeMwlnclQ1tYI69bz+x/9hmfv+xP5nB4FLANXMpXk45edxccuOYP44KHkUoMZkopR4cYZWhWtL4K7a21Z72d4SqoAKhMO1cloPb0ik80Sb9+E17SZuT/9HX+/40FymRzjp0ygbl/9EsgA5cPqFSuZO/s+nv7lHzl11pc4+rxT8VPVxMsGMainKdKkm9Zk74+7KKkCSDStI1HR/69Z7EkJfBzgbz/9HY/d+msOnT6BI4+fytCRw8KOJtKnJk4/jEnTPsKzjz3Fb2f9mOH7juagYz9CKt1WmO9UdijR0vuMcSVVAA4+TkSHv2Q60iRTSU4+69Swo8huSr67gurn5hPr7KRtwkTaJkyCWCzsWP3a6LFj+NinT+TuV++krbEZKOwH8LY+/ZnPw9y/V/LHR6soT3mce0YL0zTnNY7X+2nikioAkVI1eN5chjw+FyeXw/F9Kl9aQmb031hzxUz8RM93qMrOyeXgk+eNZsHz5bS1uziOz3/9voavnN/EzddtDDtev6bjKJE+Fq/fwJDH5+Jmszhdw67dTJrk6pXUPPNUyOlK32/+WP3ezh/A9x3aO1x+ft8gFr1cFnK6/k0FINLHqpYsxvG8bsvdbJbqhQtCSDSw/Oq3Ne/t/It1ph0eeKi6h78hW6gARPqa58F2brjc0Tla2bF8vueRLr4PGindOxWASB9rmzARv4eLvV48Qcvko0JINLCc85lmKsq7H2FVlPt8+hOtISQqHSoAkT6WHTWa5ukfxUsm3xvD5iWS5IYPp+n4fwk120Dwxc+1cMiHM1RWvF8ClRUe/zqjVSOBdkCjgEQCsOnTZ9J+8Hhq5j+D29FB62GH03rkFPxkNJ9DvyeVlfk8+cdV/O7hKn47p5pUuc8FZzVz6gltOJr2t1cqAJEgOA4dBx1Mx0EHh51kQCor8zn/sy2c/1k9IHFX6BSQiEhEqQBERCJKBSAiElEqAAmM29ZGbPPm7Y6JF5FgBXYR2BjjArcDE4E0cJG1dlnR+h8DRwNbruJ8ylrbFFQ+6TvxhgZq7/sVqXfewndc8jU11J99ri6IioQsyFFApwMpa+3UronhZwOfKlp/OHCStVZPbxpIslnGzL6RWEszjufhkMdt2ETdnT9j9cxvkNl7n7ATikRWkKeApgPzAKy1C4HJW1Z0HR0cANxpjJlvjPlSgLmkD1W9tAS3s6Pbs3CcXJYhf3kspFQiAsEWQA1QfEonb4zZcgRSCdwGnAucDFxqjJkQYDbpI4l1a3DT6W7LHd8nuWpVCIlEZIsgC6AZKH40n2utzXX9uR34kbW23VrbAjxB4VqBlLjsiFq8su6P5PWBbF1d8IFE5D1BFsB8YAZA1zWApUXrDgSeNcbEjDEJCqeLXgwwm/SRtsM+gh9P4G9zT76fSNJ44ikhpRIRCLYA5gCdxpgFwC3AVcaYmcaY06y1rwG/BhYCTwH3WWv/GWA26SN+Mlm42DtqNF4igVdWRr6ykg3nfYH02HFhxxOJtMBGAVlrPeCSbRa/XrT+JuCmoPJIcLIj61j1rWuJb9yIm0mTqRulSb1F+gE9DE4Ckxs+POwIIlJEX8NERCJKBSAiElEqABGRiFIBiIhElApARCSiVAAiIn0gl4N3V8Vpae2/ExPvcgEYY04wxvzCGDOp6/WX93wsEZHSdce9NYw6dBzjj92XuvHjOOfSkbS29b8i2J37AC4FLgC+Y4wZCkzas5FERErXr/9QzdXXj6C94/3v1w89VkX9xjh/eWB1iMm6251TQPXW2s3W2q8DJwJH7OFMIiIl67qbhm218wdIp12eeyHFa28mQkrVs90pgEe3/MFaOwu4b8/FEREpbe+u7vnESiLh8/qbyYDT9G6HBWCMudcY815qa+3Dxeuttbf1RTARkVI0amSux+W5nMP+Y7MBp+ndzhwBrASeM8bsV7zQGDPBGHN3n6QSESlR376ygYryrWfASyY8Jhyc5tCDMiGl6tkOLwJba79jjFkI/M0YcwWQAK6kMLnLj/o4n4hISbn43GY2NcT4f7cNxXV9MlmH46Z1cP9P1oUdrZudHQX0NIX5fP8EbAA+a619us9SiYiUKMeBb17RyJVf3syy5Qlqh+cZOSIfdqwe7cw1gJ9SmL2rFTiIwnSNlxtjKvo4m4hIySov9zn0oEy/3fnDzl0DWAp82Fo7yxZ8HngOWGiMObBv45WWbBZWrIr3yxs+BMjniTdswunsDDtJeLQNpMjOXAO4o4dls40xi4G5wP47+hnGGBe4ncJE72ngImvtsh7e8yjwcE+f2Z/5PvzozsFc/8Oh5HIOngdnntbKT3+wgYoKP+x4AtT8z98ZOvdPOPk8eB5th32E+rPOwe9hwvqBqubJJxj66CPvb4NJh1F/9rn4Zamwo0lIdvtZQNbaJ4Djd/LtpwMpa+1UYBYwu4f3fB8Yurt5wnTn/TVce9MwmltitHe4dKZdHnykirP/rS7saAJUL3iWYX96iFhHB24mg5vLUbn4RUbe9fOwowWm+rn5DHtkztbbYMli6n4RnW0g3X2gh8FZa1fu5FunU7iIjLV2ITC5eKUx5gzAAx77IHnCcv3s7nf+daZd/v50Be+8q1k3wzb00T/hZrYefufmspQve4N4/YaQUgVryNyetkGO1Ftvkli/PqRUEragngZaAzQVvc4bY+IAxpjxwOeBawPKskdls7BhY6zHdWVJH/tW/7rzL3I8j3jT5h5X+bE4yXX9b2jeHuf7xBsbe14Vi5FYH4FtID0KqgCaKdw38N7nWmu33C53PjCGwuiiLwIzjTEnB5TrA4vHYdiQnq/yp7MO++/Xv+78ixzXJVdd0+MqJ58jO6I24EAhcBzyNYN6XpXPkx0xIuBA0l8EVQDzgRkAxpgpFEYWAWCtvdpae5S19jjgHuCH1tp5AeX6wBwHZl3e/c6/sqTHtMmd/e7W7yhqPOkUvOTWR2JePE563/3I1kXjOk3jyTO6b4NYnPQ++5IdNTqkVBK2oE5QzwFOMMYsABzgAmPMTGCZtfaRgDL0mSsubmJzc4wf/mwIsVjhzr8Tj23n3tt0brU/aD72eGLt7Qz+2+PguJDP0fHhg9jwhQvDjhaY5mOOxW1rY8hf54HrQi5HhzmIDV/4UtjRJESBFIC11gMu2Wbx6z2877tB5NnTHAe++/UGrr60kbdWJKirzTNiWP+9+SNyHIfGGaey+eMnkthYT766mvx2TgsNWI7D5lM+QdPHTiBRX0++JoLbQLrREJU9qKLC73cPe5L3+ckkmdFjwo4RKj+ZJDMm2ttA3qc5gUVEIkoFICISUSoAEZGIUgGIiESUCkBEJKJUACIiEaUCEBGJKBWAiEhEqQBERCJKBSAiElEqABGRiFIBiIhElApARCSiVAAiIhGlAhARiSgVgATGbW0l3tAAvh92lNBoG4Qvm4XlK+M0t2j3F8iEMMYYF7gdmAikgYustcuK1l9GYUJ4H7jeWvvnIHJJMOINm6i955ek3l2B7zjkq6qoP/tcOg4eH3a0wMQbGrq2wXJ8x8GrrKT+7HNpP+TQsKNFyk9+OYjrbh5GLueQy8FpJ7Vx5+z1VFdFs5CDqsDTgZS1diowC5i9ZYUxZjhwKTAN+BjwM2OME1Au6WNONsuY/7yR1Dtv4+RyuNksicZG6n5xB8mV74YdLxjZLGNm30hq+fvbIL55MyPvupOyFcvDThcZ9z1QzbduGE5Tc4y2dpd0xuWRxyv59AWjw44WmqAKYDowD8BauxCYvGWFtXYjMNFamwXqgM3W2mjW8QBUuWQxbroTZ5tTHk4ux5DHHwspVbAqX16C29mB43lbLXeyGQZHZBv0B9+9eRjtHVvv8tIZl4WLUrz2ZiKkVOEKqgBqgKai13ljzHunn6y1OWPMV4GFwO8DyiQBSKxfi5tOd1vu+D7J1atCSBS85Pp1OD1tA6BszergA0XUqjU9n/FOJHzssmTAafqHoAqgGagu/lxrba74DdbanwCjgI8aY44PKJf0sWztSLyysm7LfSA7alTwgUKQHTESfzvbIDOyLvhAETWqLtfj8lzOYf+x2YDT9A9BFcB8YAaAMWYKsHTLClPwx67z/lkKF4m9Hn+KlJy2SYfjJZL4ztaXdfxkksYTTwkpVbDaJh2Gl+xhGySSNJ48I6RU0fOdqxqoKN9615JMekwan2b8hzMhpQpXUAUwB+g0xiwAbgGuMsbMNMacZq21wEvAc8ACYKG19qmAckkf85NJ1sz8BpkxY/ASCbxkGbmqajacfwHp/caGHS8QfiLB6plXk95rb7x4YRvkq6rYcP4XSY8dF3a8yLjonGa+fWUDVRUe1ZV5yso8Pv7Rdh65b03Y0UITyDBQa60HXLLN4teL1n8P+F4QWSR42dqRrJr1f4g3NOBkMmRra8GN1hjs3IhaVl/zbWKNDbjpNNnakZHbBmFzHLjma41ccfFm3lqRoHZ4nhHD8mHHClUgBSACkBs6NOwIocsPGUq0dznhS6V8DjHRPOWzLX0FERGJKBWAiEhEqQBERCJKBSAiElEqABGRiFIBiIhElApARCSiVAAiIhGlAhARiSgVgIhIRKkAREQiSgUgIhJRKgARkYhSAYiIRJQKQEQkolQAAdmwMcaKVXF8P+wkIuFyW1qIb9oInmZ+DVsgE8IYY1zgdmAihTl/L7LWLitafxVwVtfLuV0zhA0Ib6+Ic95ldSx5pQzXhWFD8tzxnxs4+fj2sKOJBCre0EDtPXeRencFvuPgVVRQf9Y5tB86MexokRXUEcDpQMpaOxWYBczessIYMw44B5gGTAVONMZMCChXn+rsdDjmtL15fkmKdMalo9Nl1doEZ140isVLy8KOJxKcXI4xs28ktfwdnFwON5sl3tTEyLvvomz5O2Gni6ygCmA6MA/AWrsQmFy0biVwsrU23zV3cALoDChXn/rDo1W0tbt4nrPV8nTa4aafDAkplUjwKl9+CaezA2eb0z5ONsOQeXNDSiVBzQlcAzQVvc4bY+LW2py1NgtsNMY4wM3AYmvtGwHl6lOvvZGkta17x3qew8uv6QhAoiO5fh1uOt1tuQMk164OPpAAwR0BNAPVxZ9rrc1teWGMSQG/7nrPpQFl6nNm/wxVld2nAHccn0MO7P7LIDJQZWpr8cu6f+nxgUzdqOADCRBcAcwHZgAYY6YAS7es6Prm/zDwkrX2K9ba7nvMEvWZT7SSSvk4ztZDf8pTPld/rTGkVCLBa5swCa+sDN/Z+nSon0jSeNKMkFJJUKeA5gAnGGMWUDjqu8AYMxNYBsSAY4EyY8wpXe//prX2uYCy9ZmKCp9nHl7F2ZfU8fqbSWIxqKr0uOOmDUyeqCMAiZBEgtUzr2Hk3XeSXLMaXBcvmWTj584hPe5DYaeLrEAKoOvi7iXbLH696M+pIHKE4YBxWV74y0pWrYnT3uGw/9gsru6+kAjKDR/O6qu/RWxzI246TXZELfplCFdQRwCRt9fo3I7fJBIB+cFDGDDneUuc6ldEJKJUACIiEaUCEBGJKF0DkB3L56l8aTFVixfhJctomTKNzgMODDuV7CK3o4PqhfNJvfkGuWHDaZ5+LNmRI8OOJSFSAUjvsllG33YLZatX4abT+EDV4kU0HX0MDZ/5bNjpZCfFGhvY66Yf4KY7cTMZfNel5tmn2fCFL9E26fCw40lIdApIelXz3HzKVq187zZ+B3AzGQY9+wzJVSvDDSc7bfiDvyPW2oKbyQDgeB5uNkvt/ffgZLMhp5OwqACkV9X/eO69nUYxJ5elcvGiEBLJLvN9Kv+5FKeHySh8xyG17M0QQkl/oAKQ3afJbUpHbzMRaZaiyFIBSK9ajjgKL5HsttyPJ2g7TOeOS4Lj0H7Iofg93HXr+D6d+x8QQijpD1QA0quWo48hM2YMXrLwJEcf8JJJWqZOI7P3PuGGk5228czPka+owEskAPBdFy+RYMM55+Mnuxe8RINGAUmv/ESC1Vd+narFi6h68YXCMNBpR9Nx4IfDjia7IDd0GCuvvZ7q+c9S/uYb5IYNo+mjx5EdNTrsaBIiFYDsWDxO6xFH0XrEUWEnkQ/Aq6ik6YSTaDrhpLCjSD+hU0AiIhGlAhARiSgVgIhIRKkAdoLvw/KVcdZtiIUdZfdls8TrN+B2dISdRET6iUAuAhtjXOB2YCKQBi6y1i7b5j0jgAXAodbaziBy7YzHn6zgK/9ey6bGGJ4Hhx6U4b9uX8f+Y0vk9nnfZ/DfHmfIvMcAH/J52iZMov6c8/DLBuxEbCKyE4I6AjgdSFlrpwKzgNnFK40xJwF/AfrVowmXvJLkzAtHsWptgo5Ol3TG5cWlZRxz2l60tzs7/gH9QM0zTzHksUcLDwFLp3FzOSpfXsLIu+4MO5qIhCyoApgOzAOw1i4EJm+z3gM+DjQElGen3PTToXSmt97Re55DR6fD7/9cFVKqXTPksUe7PcvHzeUoX/YG8fr6kFKJSH8QVAHUAE1Fr/PGmPdOP1lr/2qt3RRQlp32ymtJPK/7N/3Wthiv2hK4e9LziLU097jKj8VJblgfcCAR6U+CKoBmoLr4c621/X6W9ENMBtft/qCsygqPDx9QAtcAXJd8dXWPq5x8jkxtbcCBRKQ/CaoA5gMzAIwxU4ClAX3uB3L1VxtJlW1dAI7jU57y+OxpLSGl2jWNJ38Cb5tnvXjxOJ0f2p/cCBWASJQFVQBzgE5jzALgFuAqY8xMY8xpAX3+bjns0DS/vXMtdbU5Kso9UmUek8anefrhVVRUlMYjdJs/ehyNJ56CV1ZW+C8ep338BNZddEnY0UQkZIEMA7XWesC2e5zXe3jffkHk2RUzPtbOuy++w9srEpSnPMaMyocdadc4DptPnkHTx04g3rCJfFU1XmVl2KlEpB/Qw+B2gutSOuP+t8NPJMiOrAs7hoj0I7oTWEQkolQAIiIRpQIQEYkoFYCISESpAEREIkoFICISUSoAEZGIUgGIiESUCkBEJKJUACIiEaUCEBGJKBWAiEhEqQBERCJKBSAiElEqABGRiFIBiIhEVGATwhhjXOB2YCKQBi6y1i4rWn8x8BUgB3zfWvvnoLJTyf4rAAAEhklEQVSJiERRkEcApwMpa+1UYBYwe8sKY0wdcDlwNHAS8ANjTFmA2UREIifIApgOzAOw1i4EJhetOxKYb61NW2ubgGXAhACziYhETpBzAtcATUWv88aYuLU218O6FmBQ0esYwLr6jX0esr8aNmEch35yCuubm3b8ZpEBpMPPMelfp+MOr2b12vVhxykpRfvMWE/rgyyAZqC66LXbtfPvaV01sLno9SiA8y6/pk8DloSX/hF2ApFwfOf5sBOUslHAW9suDLIA5gOfBB4wxkwBlhat+1/gP4wxKaAMOAh4pWj988AxwFogH0xcEZGSF6Ow8++xPR3f9wNJUTQKaALgABcAM4Bl1tpHukYBfZnCdYkbrLV/CCSYiEhEBVYAQdFw053aBlcBZ3W9nGut/V7wKfvWjrZB0XseBR621t4RfMq+tRP/Dk4Brut6+SJwmbV2QO0QdmIbfB04G/AofPGcE0rQkAzEG8E03LT3bTAOOAeYBkwFTjTGDMQRV9vdBkW+DwwNNFWwevt3UA3cDJxqrZ0CLAeGhxGyj/W2DQZT2B9MBU4Ebg0lYYgGYgFouGnv22AlcLK1Nm+t9YAE0Bl8xD7X2zbAGHMGhW99jwUfLTC9bYNpFK7DzTbGPAOst9bWBx+xz/W2DdqAFUBl139e4OlCNhALoMfhpttZt+1w04Fiu9vAWpu11m40xjjGmP8EFltr3wglZd/a7jYwxowHPg9cG0awAPX2uzAcOB64BjgFuNIYc2DA+YLQ2zaAwheiVymcAvtxkMH6g4FYAB9kuOlA0ds2oGu01a+73nNpwNmC0ts2OB8YAzwBfBGYaYw5Odh4gehtG2wCnrfWrrPWtgJPA5OCDhiA3rbBKRRGyIwF9gFON8YcGXC+UA3EAphPYXQR2xlueowxJmWMGUT34aYDxXa3gTHGAR4GXrLWfsVaO1CH1W53G1hrr7bWHmWtPQ64B/ihtXZeGCH7WG+/C4uA8caY4V3fiKdQ+CY80PS2DRqBDiBtre2k8GVwcOAJQzSQRwFFdrhpb9uAwrjg/wYWFv2Vb1prnws6Z1/a0b+Dovd9F1g3wEcBbe934SzgG11vf8Bae2M4SfvOTmyD7wEnUzj//yxw9UAbCdWbAVcAIiKycwbiKSAREdkJKgARkYhSAYiIRJQKQEQkolQAIiIRpQIQEYkoFYCISESpAER2kTHm34wxtxe9/r4x5v4wM4nsjiBnBBMZKO4FrDHmWxSeNvkJCk/XFCkpuhNYZDcYY26i8AjhU4ATrLXd5lsV6e90BCCye+4GXgM+pZ2/lCoVgMjuuRaop+h3qGu2tW8Dg6y1Z4QVTGRn6SKwyC4yxvw7kAI+C1yxZbm19m1r7YWhBRPZRSoAkV1gjPkXCo8U/oK19kmgxhgzECdSkQhQAYjsJGPMPsBdwJnW2pauxT8Crgwvlcju0yggkT3EGDMM+A/gBOAua+0PQo4k0isVgIhIROkUkIhIRKkAREQiSgUgIhJRKgARkYhSAYiIRJQKQEQkolQAIiIRpQIQEYkoFYCISET9f2H8zaUqcEwvAAAAAElFTkSuQmCC" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0</span><br></pre></td></tr></table></figure>
<h2 id="Python-implementation"><a href="#Python-implementation" class="headerlink" title="Python implementation"></a>Python implementation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">def AdaBoost_scratch(X,y, M&#x3D;10, learning_rate &#x3D; 1):</span><br><span class="line">    #Initialization of utility variables</span><br><span class="line">    N &#x3D; len(y)</span><br><span class="line">    estimator_list, y_predict_list, estimator_error_list, estimator_weight_list, sample_weight_list &#x3D; [], [],[],[],[]</span><br><span class="line"></span><br><span class="line">    #Initialize the sample weights</span><br><span class="line">    sample_weight &#x3D; np.ones(N) &#x2F; N</span><br><span class="line">    sample_weight_list.append(sample_weight.copy())</span><br><span class="line"></span><br><span class="line">    #For m &#x3D; 1 to M</span><br><span class="line">    for m in range(M):   </span><br><span class="line"></span><br><span class="line">        #Fit a classifier</span><br><span class="line">        estimator &#x3D; DecisionTreeClassifier(max_depth &#x3D; 1, max_leaf_nodes&#x3D;2)</span><br><span class="line">        estimator.fit(X, y, sample_weight&#x3D;sample_weight)</span><br><span class="line">        y_predict &#x3D; estimator.predict(X)</span><br><span class="line"></span><br><span class="line">        #Misclassifications</span><br><span class="line">        incorrect &#x3D; (y_predict !&#x3D; y)</span><br><span class="line"></span><br><span class="line">        #Estimator error</span><br><span class="line">        estimator_error &#x3D; np.mean( np.average(incorrect, weights&#x3D;sample_weight, axis&#x3D;0))</span><br><span class="line">        </span><br><span class="line">        #Boost estimator weights</span><br><span class="line">        estimator_weight &#x3D;  learning_rate * np.log((1. - estimator_error) &#x2F; estimator_error)</span><br><span class="line"></span><br><span class="line">        #Boost sample weights</span><br><span class="line">        sample_weight *&#x3D; np.exp(estimator_weight * incorrect * ((sample_weight &gt; 0) | (estimator_weight &lt; 0)))</span><br><span class="line"></span><br><span class="line">        #Save iteration values</span><br><span class="line">        estimator_list.append(estimator)</span><br><span class="line">        y_predict_list.append(y_predict.copy())</span><br><span class="line">        estimator_error_list.append(estimator_error.copy())</span><br><span class="line">        estimator_weight_list.append(estimator_weight.copy())</span><br><span class="line">        sample_weight_list.append(sample_weight.copy())</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #Convert to np array for convenience   </span><br><span class="line">    estimator_list &#x3D; np.asarray(estimator_list)</span><br><span class="line">    y_predict_list &#x3D; np.asarray(y_predict_list)</span><br><span class="line">    estimator_error_list &#x3D; np.asarray(estimator_error_list)</span><br><span class="line">    estimator_weight_list &#x3D; np.asarray(estimator_weight_list)</span><br><span class="line">    sample_weight_list &#x3D; np.asarray(sample_weight_list)</span><br><span class="line"></span><br><span class="line">    #Predictions</span><br><span class="line">    preds &#x3D; (np.array([np.sign((y_predict_list[:,point] * estimator_weight_list).sum()) for point in range(N)]))</span><br><span class="line">    print(&#39;Accuracy &#x3D; &#39;, (preds &#x3D;&#x3D; y).sum() &#x2F; N) </span><br><span class="line">    </span><br><span class="line">    return estimator_list, estimator_weight_list, sample_weight_list</span><br></pre></td></tr></table></figure>
<h3 id="Running-scratch-AdaBoost"><a href="#Running-scratch-AdaBoost" class="headerlink" title="Running scratch AdaBoost"></a>Running scratch AdaBoost</h3><p>Accuracy = 100% - same as for Sklearn implementation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">estimator_list, estimator_weight_list, sample_weight_list  &#x3D; AdaBoost_scratch(X,y, M&#x3D;10, learning_rate &#x3D; 1)</span><br><span class="line">Accuracy &#x3D;  1.0</span><br></pre></td></tr></table></figure>
<h2 id="Adaboost-scratch-Plotting-utility-function"><a href="#Adaboost-scratch-Plotting-utility-function" class="headerlink" title="Adaboost_scratch Plotting utility function"></a>Adaboost_scratch Plotting utility function</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def plot_AdaBoost_scratch_boundary(estimators,estimator_weights, X, y, N &#x3D; 10,ax &#x3D; None ):</span><br><span class="line">    </span><br><span class="line">    def AdaBoost_scratch_classify(x_temp, est,est_weights ):</span><br><span class="line">        &#39;&#39;&#39;Return classification prediction for a given point X and a previously fitted AdaBoost&#39;&#39;&#39;</span><br><span class="line">        temp_pred &#x3D; np.asarray( [ (e.predict(x_temp)).T* w for e, w in zip(est,est_weights )]  ) &#x2F; est_weights.sum()</span><br><span class="line">        return np.sign(temp_pred.sum(axis &#x3D; 0))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#39;&#39;&#39;Utility function to plot decision boundary and scatter plot of data&#39;&#39;&#39;</span><br><span class="line">    x_min, x_max &#x3D; X[:, 0].min() - .1, X[:, 0].max() + .1</span><br><span class="line">    y_min, y_max &#x3D; X[:, 1].min() - .1, X[:, 1].max() + .1</span><br><span class="line">    xx, yy &#x3D; np.meshgrid( np.linspace(x_min, x_max, N), np.linspace(y_min, y_max, N))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    zz &#x3D; np.array( [AdaBoost_scratch_classify(np.array([xi,yi]).reshape(1,-1), estimators,estimator_weights ) for  xi, yi in zip(np.ravel(xx), np.ravel(yy)) ] )</span><br><span class="line">            </span><br><span class="line">    # reshape result and plot</span><br><span class="line">    Z &#x3D; zz.reshape(xx.shape)</span><br><span class="line">    cm_bright &#x3D; ListedColormap([&#39;#FF0000&#39;, &#39;#0000FF&#39;])</span><br><span class="line">    </span><br><span class="line">    if ax is None:</span><br><span class="line">        ax &#x3D; plt.gca()</span><br><span class="line">    ax.contourf(xx, yy, Z, 2, cmap&#x3D;&#39;RdBu&#39;, alpha&#x3D;.5)</span><br><span class="line">    ax.contour(xx, yy, Z,  2, cmap&#x3D;&#39;RdBu&#39;)</span><br><span class="line">    ax.scatter(X[:,0],X[:,1], c &#x3D; y, cmap &#x3D; cm_bright)</span><br><span class="line">    ax.set_xlabel(&#39;$X_1$&#39;)</span><br><span class="line">    ax.set_ylabel(&#39;$X_2$&#39;)</span><br></pre></td></tr></table></figure>
<h2 id="Plotting-resulting-decision-boundary"><a href="#Plotting-resulting-decision-boundary" class="headerlink" title="Plotting resulting decision boundary"></a>Plotting resulting decision boundary</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_AdaBoost_scratch_boundary(estimator_list, estimator_weight_list, X, y, N &#x3D; 50 )</span><br></pre></td></tr></table></figure>
<p><img src="data:image/png;base64,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" alt="img"></p>
<h1 id="Viewing-decision-boundaries-of-the-weak-classifiers-inside-AdaBoost"><a href="#Viewing-decision-boundaries-of-the-weak-classifiers-inside-AdaBoost" class="headerlink" title="Viewing decision boundaries of the weak classifiers inside AdaBoost"></a>Viewing decision boundaries of the weak classifiers inside AdaBoost</h1><ul>
<li>$M = 10$ iterations</li>
<li>Size of scatter points is proportional to scale of sample_weights</li>
</ul>
<p>For example, in the top left plot $m = 0$, 6 blue points are misclassified. In the next ieration $m=1$, their sample weight is increased and the scatter plot shows them as bigger.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">estimator_list, estimator_weight_list, sample_weight_list  &#x3D; AdaBoost_scratch(X,y, M&#x3D;10, learning_rate &#x3D; 1)</span><br><span class="line"></span><br><span class="line">fig &#x3D; plt.figure(figsize &#x3D; (14,14))</span><br><span class="line">for m in range(0,9):</span><br><span class="line">    fig.add_subplot(3,3,m+1)</span><br><span class="line">    s_weights &#x3D; (sample_weight_list[m,:] &#x2F; sample_weight_list[m,:].sum() ) * 40</span><br><span class="line">    plot_decision_boundary(estimator_list[m], X,y,N &#x3D; 50, scatter_weights &#x3D;s_weights )</span><br><span class="line">    plt.title(&#39;Estimator decision boundary, m &#x3D; &#123;&#125;&#39;.format(m))</span><br><span class="line">    </span><br><span class="line">Accuracy &#x3D;  1.0</span><br></pre></td></tr></table></figure>
<p><img src="data:image/png;base64,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O6XeF88DH3ccZ9jWvRYH07m3Ikil8m4GUkDGGJOm8wOywfeE1SFsfRK2LgH1iR/UJ8ELW5eA+sQPYesSqMA+qZRV3UKzDGWpzHTecOl/gKe7/SuXGmOe8jtnl529xt0e90NgfdCrpmzNsrP3xWeBrtts326MuSaYpJ16kfdyYA6d588+Dnw76JVeKlHY+iRsXQLqEz+oT4IXti4B9YkfwtYlUJl9EurBR0REREREpDfCfqqbiIiIiIjITmnwERERERGRiqfBR0REREREKp4GHxERERERqXgafEREREREpOJp8BERERERkYqnwUdERERERCqeBh8pO8dxznUc56ZuP1/pOM7vg8wkIuGjLhGRvqI+qU7RoANIVfgtYBzH+S4wEzgOOCTYSCISQuoSEekr6pMqZHmeF3QGqQKO41wLDACOBY42xqwOOJKIhJC6RET6ivqk+uiIj/jl18BrwKdULCLyEahLRKSvqE+qjAYf8csPgI10e885jjMB+HdgkDHm5KCCiUioqEtEpK+oT6qMFjeQsnMc5yIgCZwKfLPr98aYNcaY0wMLJiKhoi4Rkb6iPqlOGnykrBzHmQUsAL5sjPkbMNBxnGnBphKRsFGXiEhfUZ9ULw0+UjaO44wDbgZOMca0bv31T4Dzg0slImGjLhGRvqI+qW5a1U0C4zjOUOAq4GjgZmPMjwKOJCIhpC4Rkb6iPqlsGnxERERERKTi6VQ3ERERERGpeBp8RERERESk4mnwERERERGRiqfBR0REREREKp4GHxERERERqXgafEREREREpOJp8BERERERkYqnwUdERERERCre/wemK44rPHNZewAAAABJRU5ErkJggg==" alt="img"></p>
<h1 id="A-visual-explanation-of-the-trade-off-between-learning-rate-and-iterations"><a href="#A-visual-explanation-of-the-trade-off-between-learning-rate-and-iterations" class="headerlink" title="A visual explanation of the trade-off between learning rate and iterations"></a>A visual explanation of the trade-off between learning rate and iterations</h1><p>This post is based on the assumption that the AdaBoost algorithm is similar to the M1 or SAMME implementations which can be sumarized as follows:</p>
<p>Let $G_m(x)  m = 1,2,…,M$ be the sequence of weak classifiers, our objective is:</p>
<script type="math/tex; mode=display">G(x) = \text{sign} \left( \alpha_1 G_1(x) + \alpha_2 G_2(x) + ... \alpha_M G_M(x)\right) = \text{sign} \left( \sum_{m = 1}^M \alpha_m G_m(x)\right)</script><p><strong>AdaBoost.M1</strong></p>
<ol>
<li><p>Initialize the obervation weights $w_i = 1/N$</p>
</li>
<li><p>For $m = 1,2,…,M$</p>
<ul>
<li><p>Compute the weighted error</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Err_m &#x3D; \frac&#123;\sum_&#123;i-1&#125;^N w_i \mathcal&#123;I&#125;(y^&#123;(i)&#125; \neq G_m(x^&#123;(i)&#125;) )&#125;&#123;\sum_&#123;i&#x3D;1&#125;^N w_i&#125;$</span><br></pre></td></tr></table></figure>
</li>
<li><p>Compute the estimator coefficient $\alpha_m = L \log \left( \frac{1 - err_m}{err_m}\right)$ where $L \leq 1$ is the learning rate</p>
</li>
<li><p>Set data weights $w_i \leftarrow w_i \exp[ \alpha_m  \mathcal{I}(y^{(i)} \neq G_m(x^{(i)}))]$</p>
</li>
<li><p>To avoid numerical instability, normalize the weights at each step $w_i \leftarrow \frac{w_1}{\sum_{i=1}^N w_i}$</p>
</li>
</ul>
</li>
<li><p>Output $G(x) = \text{sign} \left[ \sum_{m=1}^M \alpha_m G_m(x)\right]$</p>
</li>
</ol>
<h2 id="The-impact-of-Learning-Rate-L-and-the-number-of-weak-classifiers-M"><a href="#The-impact-of-Learning-Rate-L-and-the-number-of-weak-classifiers-M" class="headerlink" title="The impact of Learning Rate L and the number of weak classifiers M"></a>The impact of Learning Rate L and the number of weak classifiers M</h2><p>From the above algorithm we can understand intuitively that</p>
<ul>
<li><strong>Decreasing the learning rate</strong> $L$makes the coefficients $\alpha_m$ smaller, which reduces the amplitude of the sample_weights at each step (since $w_i \leftarrow w_i e^{ \alpha_m \mathcal{I}…} $ ). This translates into smaller variations of the weighted data points and therefore fewer differences between the weak classifier decision boundaries</li>
<li><strong>Increasing the number of weak classifiers</strong> M increases the number of iterations, and allows the sample weights to gain greater amplitude. This translates into 1) more weak classifiers to combine at the end, and 2) more variations in the decision boundaries of these classifiers. Put together these effects tend to lead to more complex overall decision boundaries.</li>
</ul>
<p>From this intuition, it would make sense to see a <strong>trade-off</strong> between the parameters $L$ and $M$. Increasing one and decreasing the other will tend to cancel the effect.</p>
<h2 id="An-example-on-a-toy-dataset"><a href="#An-example-on-a-toy-dataset" class="headerlink" title="An example on a toy dataset"></a>An example on a toy dataset</h2><p>Here is a toy dataset used on a <a href="https://stats.stackexchange.com/questions/164233/intuitive-explanations-of-differences-between-gradient-boosting-trees-gbm-ad/355618#355618" target="_blank" rel="noopener">different question</a>. Plotting the final decision boundary for different values of L and M shows there is some intuitive relation between the two.</p>
<p><a href="https://i.stack.imgur.com/D4vyy.png" target="_blank" rel="noopener"><img src="https://i.stack.imgur.com/D4vyy.png" alt="enter image description here"></a></p>
<ul>
<li>Too small $L$ or $M$ leads to an overly simplistic boundary. <strong>Left hand side plots</strong></li>
<li>Making one large and the other small tends to cancel the effect <strong>Plots in the middle</strong></li>
<li>Making both large gives a good result but may overfit <strong>Right hand side plot</strong></li>
</ul>
<h3 id="Sources-1"><a href="#Sources-1" class="headerlink" title="Sources:"></a>Sources:</h3><ul>
<li>Sklearn implementation <a href="https://github.com/scikit-learn/scikit-learn/blob/a24c8b46/sklearn/ensemble/weight_boosting.py#L297" target="_blank" rel="noopener">here</a> - line 479</li>
<li>Elements of Statistical Learning - page 339</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fig &#x3D; plt.figure(figsize &#x3D; (15,10))</span><br><span class="line">for k,l in enumerate([0.1,0.5,1]):</span><br><span class="line">    fig.add_subplot(2,3,k+1)</span><br><span class="line">    fig.subplots_adjust(hspace&#x3D;0.4, wspace&#x3D;0.4)</span><br><span class="line">    estimator_list, estimator_weight_list, sample_weight_list &#x3D; AdaBoost_scratch(X,y, M&#x3D;10, learning_rate &#x3D; l)</span><br><span class="line">    plot_AdaBoost_scratch_boundary(estimator_list,estimator_weight_list, X, y, N &#x3D; 50,ax &#x3D; None )</span><br><span class="line">    plt.title(&#39;Adaboost boundary: M &#x3D; 10,  L &#x3D; &#123;&#125;&#39;.format(l))</span><br><span class="line">    print(estimator_weight_list)</span><br><span class="line"></span><br><span class="line">for k,m in enumerate([1,3,10]):</span><br><span class="line">    fig.add_subplot(2,3,k+4)</span><br><span class="line">    fig.subplots_adjust(hspace&#x3D;0.4, wspace&#x3D;0.4)</span><br><span class="line">    estimator_list, estimator_weight_list, sample_weight_list &#x3D; AdaBoost_scratch(X,y, M&#x3D;m, learning_rate &#x3D; 1)</span><br><span class="line">    plot_AdaBoost_scratch_boundary(estimator_list,estimator_weight_list, X, y, N &#x3D; 50,ax &#x3D; None )</span><br><span class="line">    plt.title(&#39;Adaboost boundary: M &#x3D; &#123;&#125;,  L &#x3D; 1&#39;.format(m))</span><br><span class="line">    print(estimator_weight_list)</span><br><span class="line">Accuracy &#x3D;  0.7391304347826086</span><br><span class="line">[0.10414539 0.09373085 0.08435776 0.07592199 0.06832979 0.06149681</span><br><span class="line"> 0.05534713 0.0549876  0.05308348 0.05268687]</span><br><span class="line">Accuracy &#x3D;  0.8695652173913043</span><br><span class="line">[0.52072694 0.26823221 0.34353197 0.2425222  0.31806477 0.3092209</span><br><span class="line"> 0.31967048 0.29344342 0.25530824 0.30996101]</span><br><span class="line">Accuracy &#x3D;  1.0</span><br><span class="line">[1.04145387 0.87546874 0.83739679 0.78053386 1.03993142 0.93832294</span><br><span class="line"> 0.62863165 0.8769354  0.77916076 1.05526061]</span><br><span class="line">Accuracy &#x3D;  0.7391304347826086</span><br><span class="line">[1.04145387]</span><br><span class="line">Accuracy &#x3D;  0.8695652173913043</span><br><span class="line">[1.04145387 0.87546874 0.83739679]</span><br><span class="line">Accuracy &#x3D;  1.0</span><br><span class="line">[1.04145387 0.87546874 0.83739679 0.78053386 1.03993142 0.93832294</span><br><span class="line"> 0.62863165 0.8769354  0.77916076 1.05526061]</span><br></pre></td></tr></table></figure>
<p><img src="data:image/png;base64,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eBs4XQVDREJO9UxESolqWglTYyfF8J9AHb1+v4wxOwFXANXW2rOCCiYiMkCqZyJSSlTTSpgmT5FBZYz5FlAGnAN8fe1ya+371toLAwsmIjJAqmciUkpU00qfGjsZNMaYY4HZwGestU8BVcaYfYNNJSIycKpnIlJKVNO2D2rsZFAYY6YANwJnW2vb8ouvAb4RXCoRkYFTPRORUqKatv3QrJjiC2PMSOCnwPHAjdba/w44kojIVlE9E5FSoppWOtTYiYiIiIiIhJyGYoqIiIiIiIScGjsREREREZGQU2MnIiIiIiIScmrsREREREREQk6NnYiIiIiISMipsRMREREREQk5NXYiIiIiIiIhp8ZOREREREQk5NTYiYiIiIiIhJwaOxERERERkZBTYyciIiIiIhJyauxERERERERCTo2diIiIiIhIyKmxExERERERCTk1diIiIiIiIiGnxk5ERERERCTk1NiJiIiIiIiEnBo7ERERERGRkFNjJyIiIiIiEnJq7EREREREREJOjZ2IiIiIiEjIqbETEREREREJOTV2IiIiIiIiIafGTkREREREJOTU2ImIiIiIiIScGjsREREREZGQU2MnIiIiIiIScmrsREREREREQk6NnYiIiIiISMipsRMREREREQk5NXYiIiIiIiIhp8ZOREREREQk5NTYiYiIiIiIhJwaOxERERERkZBTYyciIiIiIhJyauxERERERERCTo2diIiIiIhIyKmxExERERERCTk1diIiIiIiIiGnxk5ERERERCTk1NiJiIiIiIiEnBo7ERERERGRkFNjJyIiIiIiEnJq7EREREREREJOjZ2IiIiIiEjIqbETEREREREJOTV2IiIiIiIiIafGTkREREREJOTU2OUZY+LGmJXGmIc38ZizjDFPbcFrecaYUYMasPB2/mCMOaDA8s8aYx4o9vY3kulNY8zRPmznlvz7fMwGy6caY1xjzG8GaTufM8bcv5XPLcrvgTFmH2PMysF+XSktqmmDlqkkapox5hhjzMvGmDeMMfONMQdvxWuopolvVMMGLVNJ1LBer9dvvyy/7C1jzLvGmN8aY+IDfM2i/XyMMT8erO99S6ixW+9M4HXgQGPMbkGH2ULHA07QIQK0FPj0BssuANZs6wsbY0YYY34HXMMQeY+NMTFjzDeBR4HhQeeRIU81LXyKUtOMMQngr8Dn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" alt="img"></p>
<hr>
<h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/05/08/%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%BC%80%E5%90%AF%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E9%80%9A%E7%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%BC%80%E5%90%AF%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E9%80%9A%E7%9F%A5/" class="post-title-link" itemprop="url">三行代码开启模型训练通知</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-08 12:12:05" itemprop="dateCreated datePublished" datetime="2020-05-08T12:12:05+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-14 21:15:05" itemprop="dateModified" datetime="2020-05-14T21:15:05+08:00">2020-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nlp/" itemprop="url" rel="index"><span itemprop="name">nlp</span></a>
                </span>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果你经常在大量数据上训练模型的话，那么这样一个工具肯定很合你的胃口。这个项目叫做<a href="https://github.com/huggingface/knockknock" target="_blank" rel="noopener">knockknock</a>，它的功能只有一个：通知你训练结束了，并且附带训练的结果。</p>
<p>当前支持邮件、短信、微信群、钉钉群等通知方式，只需要三行代码，就能实现功能。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>为了让你有看下去的动力，先展示一下最终的成果(钉钉)：</p>
<p><img src="/images/%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%BC%80%E5%90%AF%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E9%80%9A%E7%9F%A5/share.jpg" alt=""></p>
<h2 id="knockknock在钉钉群中的配置方式"><a href="#knockknock在钉钉群中的配置方式" class="headerlink" title="knockknock在钉钉群中的配置方式"></a><a href="https://github.com/huggingface/knockknock" target="_blank" rel="noopener">knockknock</a>在钉钉群中的配置方式</h2><p>之所以选择使用钉钉，是因为它的通知声音比较好听🤭。配置过程：</p>
<ol>
<li><p>建立钉钉群（最好是在电脑）</p>
</li>
<li><p>添加机器人</p>
<p>2.1 群设置$\rightarrow $智能群助手$\rightarrow $添加机器人</p>
<p>2.2 添加自定义机器人</p>
<p>2.3 自定义名字和头像</p>
<p>2.4 选择一种加密方式，推荐选择<code>加签</code></p>
<p>2.5 记录好<code>机器人的url</code>和加签生成的<code>密钥</code></p>
</li>
<li><p>在notebook或者python虚拟环境中安装knockknock</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!pip install knockknock(notebook)</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">pip install knockknock(虚拟环境)</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入dingtalk_sender</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> knockknock <span class="keyword">import</span> dingtalk_sender</span><br></pre></td></tr></table></figure>
</li>
<li><p>在要跑的类上添加以下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webhook_url = <span class="string">"https://oapi.dingtalk.com/robot/send?access_token=..."</span></span><br><span class="line"><span class="meta">@dingtalk_sender(webhook_url=webhook_url, secret="加签生成的密钥", keywords=["随便填"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_your_nicest_model</span><span class="params">(your_nicest_parameters)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'loss'</span>: <span class="number">0.9</span>&#125; <span class="comment"># Optional return value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行train_your_nicest_model，得到结果</p>
<p><img src="https://i.loli.net/2020/05/14/vzGJgxiVu5j2Scb.jpg" alt="微信图片_20200514211147"></p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>本文主要参考自官方<a href="https://github.com/huggingface/knockknock" target="_blank" rel="noopener">github仓库</a></p>
<p>以及<a href="https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq" target="_blank" rel="noopener">阿里钉钉开发者平台</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/04/29/Bert%E7%B3%BB%E5%88%97%E4%BC%B4%E7%94%9F%E7%9A%84%E6%96%B0%E5%88%86%E8%AF%8D%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/Bert%E7%B3%BB%E5%88%97%E4%BC%B4%E7%94%9F%E7%9A%84%E6%96%B0%E5%88%86%E8%AF%8D%E5%99%A8/" class="post-title-link" itemprop="url">Bert系列伴生的新分词器</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-29 09:31:52" itemprop="dateCreated datePublished" datetime="2020-04-29T09:31:52+08:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 09:53:09" itemprop="dateModified" datetime="2020-05-04T09:53:09+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nlp/" itemprop="url" rel="index"><span itemprop="name">nlp</span></a>
                </span>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>这篇文章将对Bert等模型使用的分词技术进行介绍。同时会涉及这些分词器在huggingface <a href="https://github.com/huggingface/tokenizers" target="_blank" rel="noopener">tokenizers</a>库中的使用。理解这些分词器的原理，对于灵活使用transformers库中的不同模型非常重要。除此之外，我们还能将这些分词器用于其他任务中，如果有必要的话，我们还能自己训练分词器。</p>
<h2 id="分词器是做什么的？"><a href="#分词器是做什么的？" class="headerlink" title="分词器是做什么的？"></a>分词器是做什么的？</h2><p><strong>机器无法理解文本。</strong>当我们将句子序列送入模型时，模型仅仅能看到一串字节，它无法知道一个词从哪里开始，到哪里结束，所以也不知道一个词是怎么组成的。</p>
<p>​    所以，为了帮助机器理解文本，我们需要</p>
<ol>
<li>将文本分成一个个小片段</li>
<li>然后将这些片段表示为一个向量作为模型的输入</li>
<li>同时，我们需要将一个个小片段（token) 表示为向量，作为词嵌入矩阵， 通过在语料库上训练来优化token的表示，使其蕴含更多有用的信息，用于之后的任务。</li>
</ol>
<h2 id="古典分词方法"><a href="#古典分词方法" class="headerlink" title="古典分词方法"></a>古典分词方法</h2><p><img src="/images/Bert%E7%B3%BB%E5%88%97%E4%BC%B4%E7%94%9F%E7%9A%84%E6%96%B0%E5%88%86%E8%AF%8D%E5%99%A8/tokenize.png" alt="tokenize"></p>
<h3 id="基于空格的分词方法"><a href="#基于空格的分词方法" class="headerlink" title="基于空格的分词方法"></a>基于空格的分词方法</h3><p>一个句子，使用不同的规则，将有许多种不同的分词结果。我们之前常用的分词方法将空格作为分词的边界。也就是图中的第三种方法。但是，这种方法存在问题，即只有在训练语料中出现的token才能被训练器学习到，而那些没有出现的token将会被<code>&lt;UNK&gt;</code>等特殊标记代替，这样将影响模型的表现。如果我们将词典做得足够大，使其能容纳所有的单词。那么词典将非常庞大，产生很大的开销。同时对于出现次数很少的词，学习其token的向量表示也非常困难。除去这些原因，有很多语言不用空格进行分词，也就无法使用基于空格分词的方法。综上，我们需要新的分词方法来解决这些问题。</p>
<h3 id="基于字母的分词方法"><a href="#基于字母的分词方法" class="headerlink" title="基于字母的分词方法"></a>基于字母的分词方法</h3><p>简单来说，就是将每个字符看作一个词。</p>
<p><strong>优点</strong>： 不用担心未知词汇，可以为每一个单词生成词嵌入向量表示。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>字母本身就没有任何的内在含义，得到的词嵌入向量缺乏含义。</li>
<li>计算复杂度提升（字母的数目远大于token的数目）</li>
<li>输出序列的长度将变大，对于Bert、CNN等限制最大长度的模型将很容易达到最大值。</li>
</ul>
<h2 id="基于子词的分词方法（Subword-Tokenization）"><a href="#基于子词的分词方法（Subword-Tokenization）" class="headerlink" title="基于子词的分词方法（Subword Tokenization）"></a>基于子词的分词方法（Subword Tokenization）</h2><p>为了改进分词方法，在<code>&lt;UNK&gt;</code>数目和词向量含义丰富性之间达到平衡，提出了Subword Tokenization方法。这种方法的目的是通过一个有限的单词列表来解决所有单词的分词问题，同时将结果中token的数目降到最低。例如，可以用更小的词片段来组成更大的词：</p>
<p>“<strong><em>unfortunately</em></strong>” = “<strong><em>un</em></strong>” + “<strong><em>for</em></strong>” + “<strong><em>tun</em></strong>” + “<strong><em>ate</em></strong>” + “<strong><em>ly</em></strong>”。</p>
<p>接下来，将介绍几种不同的Subword Tokenization方法。</p>
<h3 id="Byte-Pair-Encoding-BPE-字节对编码"><a href="#Byte-Pair-Encoding-BPE-字节对编码" class="headerlink" title="Byte Pair Encoding (BPE) 字节对编码"></a>Byte Pair Encoding (BPE) 字节对编码</h3><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>字节对编码最早是在信号压缩领域提出的，后来被应用于分词任务中。在信号压缩领域中BPE过程可视化如下：</p>
<p><img src="/images/Bert%E7%B3%BB%E5%88%97%E4%BC%B4%E7%94%9F%E7%9A%84%E6%96%B0%E5%88%86%E8%AF%8D%E5%99%A8/1_x1Y_n3sXGygUPSdfXTm9pQ.gif" alt="1_x1Y_n3sXGygUPSdfXTm9pQ"></p>
<p>接下来重点介绍将BPE应用于分词任务的流程：</p>
<h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><ol>
<li>根据语料库建立一个词典，词典中仅包含单个字符，如英文中就是a-z</li>
<li>统计语料库中出现次数最多的字符对（词典中两项的组合），然后将字符对加入到词典中</li>
<li>重复步骤2直到到达规定的步骤数目或者词典尺寸缩小到了指定的值。</li>
</ol>
<h3 id="BPE的优点"><a href="#BPE的优点" class="headerlink" title="BPE的优点"></a>BPE的优点</h3><p>可以很有效地平衡词典尺寸和编码步骤数(将句子编码所需要的token数量)</p>
<h3 id="BPE存在的缺点："><a href="#BPE存在的缺点：" class="headerlink" title="BPE存在的缺点："></a><strong>BPE</strong>存在的缺点：</h3><p><img src="/images/Bert%E7%B3%BB%E5%88%97%E4%BC%B4%E7%94%9F%E7%9A%84%E6%96%B0%E5%88%86%E8%AF%8D%E5%99%A8/image-20200429104839759.png" alt="image-20200429104839759"></p>
<ul>
<li>对于同一个句子, 例如Hello world，如图所示，可能会有不同的Subword序列。不同的Subword序列会产生完全不同的id序列表示，这种歧义可能在解码阶段无法解决。在翻译任务中，不同的id序列可能翻译出不同的句子，这显然是错误的。</li>
<li>在训练任务中，如果能对不同的Subword进行训练的话，将增加模型的健壮性，能够容忍更多的噪声，而BPE的贪心算法无法对随机分布进行学习。</li>
</ul>
<h3 id="Unigram-Based-Tokenization"><a href="#Unigram-Based-Tokenization" class="headerlink" title="Unigram Based Tokenization"></a>Unigram Based Tokenization</h3><h3 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h3><p>分词中的Unigram模型是<strong>Kudo.</strong>在论文<strong>“Subword Regularization: Improving Neural Network Translation Models with Multiple Subword Candidates”</strong>中提出的。当时主要是为了解决机器翻译中分词的问题。作者使用一种叫做<code>marginalized likelihood</code>的方法来建模翻译问题，考虑到不同分词结果对最终翻译结果的影响，引入了分词概率$P(\vec{x}|X)$来表示$X$最终分词为$\vec{x}$的概率(X为原始的句子, $\vec{x}$为分词的结果$\vec{x} = (x_1, . . . , x_M) $，由多个subword组成)。传统的BPE算法无法对这个概率进行建模，因此作者使用了Unigram语言模型来达到这样的目的。</p>
<h3 id="方法执行过程"><a href="#方法执行过程" class="headerlink" title="方法执行过程"></a>方法执行过程</h3><p><strong>假设</strong>：根据unigram的假设，每个字词的出现是独立的。所以</p>
<script type="math/tex; mode=display">
P(\vec{x}) = \prod_{i=1}^{M}p(x_i)</script><p>这里的$x_i$是从预先定义好的词典$V$中取得的，所以，最有可能的分词方式就可以这样表示：</p>
<script type="math/tex; mode=display">
x^* =\underset{x\in S(X)}{arg\;max}\;P(\vec{x})</script><p>这里$S(X)$是句子$X$不同的分词结果集合。$x^*$可以通过维特比算法得到。</p>
<p>如果已知词典$V$, 我们可以通过EM算法来估计$p(x_i)$，其中M步最大化的对象是以下似然函数（原谅我这里偷懒直接使用图片）：</p>
<p><img src="/images/Bert%E7%B3%BB%E5%88%97%E4%BC%B4%E7%94%9F%E7%9A%84%E6%96%B0%E5%88%86%E8%AF%8D%E5%99%A8/image-20200501185312612.png" alt="image-20200501185312612"></p>
<p>$|D|$是语料库中语料数量。</p>
<p><strong>我是这样理解这个似然函数的：</strong>将语料库中所有句子的所有分词组合形成的概率相加。</p>
<p>初始时，我们连词典$V$都没有，作者通过不断执行以下步骤来构造合适的词典以及分词概率：</p>
<ol>
<li><p>从头构建一个相当大的种子词典。</p>
</li>
<li><p>重复以下步骤，知道字典尺寸$|V|$减小到期望值：</p>
<ul>
<li><p>固定词典，通过EM算法优化$p(x)$</p>
</li>
<li><p>为每一个子词计算$loss_i$，loss代表如果将某个词去掉，上述似然函数值会减少多少。根据loss排序，保留loss最高的$\eta$个子词。注意：保留所有的单字符，从而避免OOV情况。</p>
<p><strong>我是这样理解loss的：</strong>若某个子词经常以很高的频率出现在很多句子的分词结果中，那么其损失将会很大，所以要保留这样的子词。</p>
</li>
</ul>
</li>
</ol>
<h3 id="主要贡献："><a href="#主要贡献：" class="headerlink" title="主要贡献："></a>主要贡献：</h3><ol>
<li>使用的训练算法可以利用所有可能的分词结果，这是通过data sampling算法实现的。</li>
<li>提出一种基于语言模型的分词算法，这种语言模型可以给多种分词结果赋予概率，从而可以学得其中的噪声。</li>
</ol>
<h2 id="将基于子词的分词方法应用到实际中"><a href="#将基于子词的分词方法应用到实际中" class="headerlink" title="将基于子词的分词方法应用到实际中"></a>将基于子词的分词方法应用到实际中</h2><h3 id="Bert中的WordPiece分词器"><a href="#Bert中的WordPiece分词器" class="headerlink" title="Bert中的WordPiece分词器"></a>Bert中的WordPiece分词器</h3><p>WordPiece是随着Bert论文的出现被提出的。在整体步骤上，WordPiece方法和BPE是相同的。即也是自低向上地构建词典。区别是BPE在每次合并的时候都选择出现次数最高的字符对，而WordPiece使用的是类似于Unigram的方法，即通过语言模型来得到合并两个单词可能造成的影响，然后选择使得似然函数提升最大的字符对。这个提升是通过结合后的字符对减去结合前的字符对之和得到的。也就是说，判断“de”相较于“d”+”e”是否更适合出现。</p>
<p>三种分词器的关系如下：(图自<a href="https://blog.floydhub.com/tokenization-nlp/" target="_blank" rel="noopener">FloudHub Blog</a>)</p>
<p><img src="/images/Bert%E7%B3%BB%E5%88%97%E4%BC%B4%E7%94%9F%E7%9A%84%E6%96%B0%E5%88%86%E8%AF%8D%E5%99%A8/subword-probabilistic-tokenization.png" alt="Frequency V probability approaches"></p>
<h3 id="SentencePiece库"><a href="#SentencePiece库" class="headerlink" title="SentencePiece库"></a>SentencePiece库</h3><p>SentencePiece是在“SentencePiece: A simple and language independent subword tokenizer<br>and detokenizer for Neural Text Processing”这篇文章中介绍的。其主要是为了解决不同语言分词规则需要特别定义的问题，比如下面这种情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Raw text: Hello world.</span><br><span class="line">Tokenized: [Hello] [world] [.]</span><br><span class="line">Decoded text: Hello world .</span><br></pre></td></tr></table></figure>
<p>将分词结果解码到原来的句子中时，会在不同的词之间添加空格，生成<code>Decoded text</code>所示的结果，这就是编码解码出现的歧义性，因此需要特别定义规则来实现互逆。还有一个例子是，在解码阶段，欧洲语言词之间要添加空格，而中文等语言则不应添加空格。对于这种区别，也需要单独定制规则，这些繁杂的规则维护起来非常困难，所以作者采用以下的方案来解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将所有的字符都转化成Unicode编码，空格用‘_’来代替，然后进行分词操作。这样空格也不需要特别定义规则了。然后在解码结束后，使用Python代码恢复即可：</span><br><span class="line">detok = ’’.join(tokens).replace(’_’, ’ ’)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/google/sentencepiece" target="_blank" rel="noopener">SentencePiece库</a>主要由以下部分组成：</p>
<p><strong>“Normalizer, Trainer, Encoder,  Decoder”</strong></p>
<p>其中Normalizer用来对Unicode编码进行规范化，这里使用的算法是<code>NFKC</code>方法，同时也支持自定义规范化方法。Trainer则用来训练分词模型。Encoder是将句子变成编码，而Decoder是反向操作。他们之间存在以下函数关系：</p>
<script type="math/tex; mode=display">
Decode(Encode(Normalize(text))) = Normalize(text):</script><h3 id="Huggingface-tokenizers库的介绍和使用"><a href="#Huggingface-tokenizers库的介绍和使用" class="headerlink" title="Huggingface tokenizers库的介绍和使用"></a>Huggingface tokenizers库的介绍和使用</h3><p><a href="https://github.com/huggingface/tokenizers" target="_blank" rel="noopener">tokenizers</a>是集合了当前最常用的分词器集合，效率和易用性也是其关注的范畴。</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tokenizers provides ultra-fast implementations of most current tokenizers:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tokenizers <span class="keyword">import</span> (ByteLevelBPETokenizer,</span><br><span class="line">                            CharBPETokenizer,</span><br><span class="line">                            SentencePieceBPETokenizer,</span><br><span class="line">                            BertWordPieceTokenizer)</span><br><span class="line"><span class="comment"># Ultra-fast =&gt; they can encode 1GB of text in ~20sec on a standard server's CPU</span></span><br><span class="line"><span class="comment"># Tokenizers can be easily instantiated from standard files</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokenizer = BertWordPieceTokenizer(<span class="string">"bert-base-uncased-vocab.txt"</span>, lowercase=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tokenizers provide exhaustive outputs: tokens, mapping to original string, attention/special token masks.</span></span><br><span class="line"><span class="comment"># They also handle model's max input lengths as well as padding (to directly encode in padded batches)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output = tokenizer.encode(<span class="string">"Hello, y'all! How are you 😁 ?"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(output.ids, output.tokens, output.offsets)</span><br><span class="line">[<span class="number">101</span>, <span class="number">7592</span>, <span class="number">1010</span>, <span class="number">1061</span>, <span class="number">1005</span>, <span class="number">2035</span>, <span class="number">999</span>, <span class="number">2129</span>, <span class="number">2024</span>, <span class="number">2017</span>, <span class="number">100</span>, <span class="number">1029</span>, <span class="number">102</span>]</span><br><span class="line">[<span class="string">'[CLS]'</span>, <span class="string">'hello'</span>, <span class="string">','</span>, <span class="string">'y'</span>, <span class="string">"'"</span>, <span class="string">'all'</span>, <span class="string">'!'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'[UNK]'</span>, <span class="string">'?'</span>, <span class="string">'[SEP]'</span>]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">5</span>), (<span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>), (<span class="number">8</span>, <span class="number">9</span>), (<span class="number">9</span>, <span class="number">12</span>), (<span class="number">12</span>, <span class="number">13</span>), (<span class="number">14</span>, <span class="number">17</span>), (<span class="number">18</span>, <span class="number">21</span>), (<span class="number">22</span>, <span class="number">25</span>), (<span class="number">26</span>, <span class="number">27</span>),(<span class="number">28</span>, <span class="number">29</span>), (<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line"><span class="comment"># Here is an example using the offsets mapping to retrieve the string corresponding to the 10th token:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output.original_str[output.offsets[<span class="number">10</span>]]</span><br><span class="line"><span class="string">'😁'</span></span><br></pre></td></tr></table></figure>
<h3 id="自己训练分词器"><a href="#自己训练分词器" class="headerlink" title="自己训练分词器"></a>自己训练分词器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can also train a BPE/Byte-levelBPE/WordPiece vocabulary on your own files</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokenizer = ByteLevelBPETokenizer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokenizer.train([<span class="string">"wiki.test.raw"</span>], vocab_size=<span class="number">20000</span>)</span><br><span class="line">[<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>] Tokenize words                 ████████████████████████████████████████   <span class="number">20993</span>/<span class="number">20993</span></span><br><span class="line">[<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>] Count pairs                    ████████████████████████████████████████   <span class="number">20993</span>/<span class="number">20993</span></span><br><span class="line">[<span class="number">00</span>:<span class="number">00</span>:<span class="number">03</span>] Compute merges                 ████████████████████████████████████████   <span class="number">19375</span>/<span class="number">19375</span></span><br></pre></td></tr></table></figure>
<h2 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h2><p>这篇文章是在Floydhub的<a href="https://blog.floydhub.com/tokenization-nlp/" target="_blank" rel="noopener">一篇博客</a>基础上扩展的。还主要参考了Unigram的原论文，BPE的官方解释等。BPE的动态图来自于Toward data science的<a href="https://towardsdatascience.com/byte-pair-encoding-the-dark-horse-of-modern-nlp-eb36c7df4f10" target="_blank" rel="noopener">有关博客</a>。除此之外，最后一章参考于tokenizers的<a href="https://github.com/huggingface/tokenizers" target="_blank" rel="noopener">官方仓库</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0notebook%E5%A4%9A%E6%8A%98%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%A0%B7%E6%9C%AC%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0notebook%E5%A4%9A%E6%8A%98%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%A0%B7%E6%9C%AC%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">深度学习Notebook多折交叉验证样本代码</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-27 11:45:20 / 修改时间：12:17:16" itemprop="dateCreated datePublished" datetime="2020-04-27T11:45:20+08:00">2020-04-27</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深度学习notebook多折交叉验证样本代码"><a href="#深度学习notebook多折交叉验证样本代码" class="headerlink" title="深度学习notebook多折交叉验证样本代码"></a>深度学习notebook多折交叉验证样本代码</h1><p><strong>这份样本代码基于 @abhishek’s <a href="https://www.kaggle.com/abhishek/bert-base-uncased-using-pytorch" target="_blank" rel="noopener">BERT Base Uncased using PyTorch</a>在tweet情感词抽取比赛上的notebook</strong>, 如果决定使用代码，请为abhishek投上一个赞成票。</p>
<h1 id="导入需要用到的包"><a href="#导入需要用到的包" class="headerlink" title="导入需要用到的包"></a>导入需要用到的包</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="comment"># tqdm用来记录notebook训练的进度条</span></span><br><span class="line"><span class="keyword">from</span> tqdm.autonotebook <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> transformers</span><br><span class="line"><span class="keyword">import</span> tokenizers</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AdamW</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> get_linear_schedule_with_warmup</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">config</span>:</span></span><br><span class="line">    MAX_LEN = <span class="number">128</span></span><br><span class="line">    TRAIN_BATCH_SIZE = <span class="number">64</span></span><br><span class="line">    VALID_BATCH_SIZE = <span class="number">16</span></span><br><span class="line">    EPOCHS = <span class="number">6</span></span><br><span class="line">    ROBERTA_PATH = <span class="string">"../input/roberta-base/"</span></span><br><span class="line">    MODEL_PATH = <span class="string">"pytorch_model.bin"</span></span><br><span class="line">    TRAINING_FILE = <span class="string">"../input/tweet-train-folds/train_folds.csv"</span></span><br><span class="line">    TOKENIZER = tokenizers.ByteLevelBPETokenizer(</span><br><span class="line">    vocab_file=<span class="string">f"<span class="subst">&#123;ROBERTA_PATH&#125;</span>/vocab.json"</span>, </span><br><span class="line">    merges_file=<span class="string">f"<span class="subst">&#123;ROBERTA_PATH&#125;</span>/merges.txt"</span>, </span><br><span class="line">    lowercase=<span class="literal">True</span>,</span><br><span class="line">    add_prefix_space=<span class="literal">True</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h1 id="Data-Processing"><a href="#Data-Processing" class="headerlink" title="Data Processing"></a>Data Processing</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_data</span><span class="params">(tweet, selected_text, sentiment, tokenizer, max_len)</span>:</span></span><br><span class="line">    tweet = <span class="string">" "</span> + <span class="string">" "</span>.join(str(tweet).split())</span><br><span class="line">    selected_text = <span class="string">" "</span> + <span class="string">" "</span>.join(str(selected_text).split())</span><br><span class="line"></span><br><span class="line">    len_st = len(selected_text) - <span class="number">1</span></span><br><span class="line">    idx0 = <span class="literal">None</span></span><br><span class="line">    idx1 = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> (i <span class="keyword">for</span> i, e <span class="keyword">in</span> enumerate(tweet) <span class="keyword">if</span> e == selected_text[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">" "</span> + tweet[ind: ind+len_st] == selected_text:</span><br><span class="line">            idx0 = ind</span><br><span class="line">            idx1 = ind + len_st - <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    char_targets = [<span class="number">0</span>] * len(tweet)</span><br><span class="line">    <span class="keyword">if</span> idx0 != <span class="literal">None</span> <span class="keyword">and</span> idx1 != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> ct <span class="keyword">in</span> range(idx0, idx1 + <span class="number">1</span>):</span><br><span class="line">            char_targets[ct] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    tok_tweet = tokenizer.encode(tweet)</span><br><span class="line">    input_ids_orig = tok_tweet.ids</span><br><span class="line">    tweet_offsets = tok_tweet.offsets</span><br><span class="line">    </span><br><span class="line">    target_idx = []</span><br><span class="line">    <span class="keyword">for</span> j, (offset1, offset2) <span class="keyword">in</span> enumerate(tweet_offsets):</span><br><span class="line">        <span class="keyword">if</span> sum(char_targets[offset1: offset2]) &gt; <span class="number">0</span>:</span><br><span class="line">            target_idx.append(j)</span><br><span class="line">    </span><br><span class="line">    targets_start = target_idx[<span class="number">0</span>]</span><br><span class="line">    targets_end = target_idx[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    sentiment_id = &#123;</span><br><span class="line">        <span class="string">'positive'</span>: <span class="number">1313</span>,</span><br><span class="line">        <span class="string">'negative'</span>: <span class="number">2430</span>,</span><br><span class="line">        <span class="string">'neutral'</span>: <span class="number">7974</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    input_ids = [<span class="number">0</span>] + [sentiment_id[sentiment]] + [<span class="number">2</span>] + [<span class="number">2</span>] + input_ids_orig + [<span class="number">2</span>]</span><br><span class="line">    token_type_ids = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] + [<span class="number">0</span>] * (len(input_ids_orig) + <span class="number">1</span>)</span><br><span class="line">    mask = [<span class="number">1</span>] * len(token_type_ids)</span><br><span class="line">    tweet_offsets = [(<span class="number">0</span>, <span class="number">0</span>)] * <span class="number">4</span> + tweet_offsets + [(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">    targets_start += <span class="number">4</span></span><br><span class="line">    targets_end += <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    padding_length = max_len - len(input_ids)</span><br><span class="line">    <span class="keyword">if</span> padding_length &gt; <span class="number">0</span>:</span><br><span class="line">        input_ids = input_ids + ([<span class="number">1</span>] * padding_length)</span><br><span class="line">        mask = mask + ([<span class="number">0</span>] * padding_length)</span><br><span class="line">        token_type_ids = token_type_ids + ([<span class="number">0</span>] * padding_length)</span><br><span class="line">        tweet_offsets = tweet_offsets + ([(<span class="number">0</span>, <span class="number">0</span>)] * padding_length)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'ids'</span>: input_ids,</span><br><span class="line">        <span class="string">'mask'</span>: mask,</span><br><span class="line">        <span class="string">'token_type_ids'</span>: token_type_ids,</span><br><span class="line">        <span class="string">'targets_start'</span>: targets_start,</span><br><span class="line">        <span class="string">'targets_end'</span>: targets_end,</span><br><span class="line">        <span class="string">'orig_tweet'</span>: tweet,</span><br><span class="line">        <span class="string">'orig_selected'</span>: selected_text,</span><br><span class="line">        <span class="string">'sentiment'</span>: sentiment,</span><br><span class="line">        <span class="string">'offsets'</span>: tweet_offsets</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Data-loader"><a href="#Data-loader" class="headerlink" title="Data loader"></a>Data loader</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TweetDataset</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Dataset which stores the tweets and returns them as processed features</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tweet, sentiment, selected_text)</span>:</span></span><br><span class="line">        self.tweet = tweet</span><br><span class="line">        self.sentiment = sentiment</span><br><span class="line">        self.selected_text = selected_text</span><br><span class="line">        self.tokenizer = config.TOKENIZER</span><br><span class="line">        self.max_len = config.MAX_LEN</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.tweet)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        data = process_data(</span><br><span class="line">            self.tweet[item], </span><br><span class="line">            self.selected_text[item], </span><br><span class="line">            self.sentiment[item],</span><br><span class="line">            self.tokenizer,</span><br><span class="line">            self.max_len</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Return the processed data where the lists are converted to `torch.tensor`s</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'ids'</span>: torch.tensor(data[<span class="string">"ids"</span>], dtype=torch.long),</span><br><span class="line">            <span class="string">'mask'</span>: torch.tensor(data[<span class="string">"mask"</span>], dtype=torch.long),</span><br><span class="line">            <span class="string">'token_type_ids'</span>: torch.tensor(data[<span class="string">"token_type_ids"</span>], dtype=torch.long),</span><br><span class="line">            <span class="string">'targets_start'</span>: torch.tensor(data[<span class="string">"targets_start"</span>], dtype=torch.long),</span><br><span class="line">            <span class="string">'targets_end'</span>: torch.tensor(data[<span class="string">"targets_end"</span>], dtype=torch.long),</span><br><span class="line">            <span class="string">'orig_tweet'</span>: data[<span class="string">"orig_tweet"</span>],</span><br><span class="line">            <span class="string">'orig_selected'</span>: data[<span class="string">"orig_selected"</span>],</span><br><span class="line">            <span class="string">'sentiment'</span>: data[<span class="string">"sentiment"</span>],</span><br><span class="line">            <span class="string">'offsets'</span>: torch.tensor(data[<span class="string">"offsets"</span>], dtype=torch.long)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TweetModel</span><span class="params">(transformers.BertPreTrainedModel)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, conf)</span>:</span></span><br><span class="line">        super(TweetModel, self).__init__(conf)</span><br><span class="line">        self.roberta = transformers.RobertaModel.from_pretrained(config.ROBERTA_PATH, config=conf)</span><br><span class="line">        self.drop_out = nn.Dropout(<span class="number">0.1</span>)</span><br><span class="line">        self.l_1 = nn.Linear(<span class="number">768</span> * <span class="number">2</span>, <span class="number">400</span>)</span><br><span class="line">        self.l0 = nn.Linear(<span class="number">400</span>, <span class="number">2</span>)</span><br><span class="line">        torch.nn.init.normal_(self.l0.weight, std=<span class="number">0.02</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, ids, mask, token_type_ids)</span>:</span></span><br><span class="line">        _, _, out = self.roberta(</span><br><span class="line">            ids,</span><br><span class="line">            attention_mask=mask,</span><br><span class="line">            token_type_ids=token_type_ids</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        out = torch.cat((out[<span class="number">-1</span>], out[<span class="number">-2</span>]), dim=<span class="number">-1</span>)</span><br><span class="line">        out = self.drop_out(out)</span><br><span class="line">        logits = self.l_1(out)</span><br><span class="line">        logits = self.l0(logits)</span><br><span class="line"></span><br><span class="line">        start_logits, end_logits = logits.split(<span class="number">1</span>, dim=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        start_logits = start_logits.squeeze(<span class="number">-1</span>)</span><br><span class="line">        end_logits = end_logits.squeeze(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> start_logits, end_logits</span><br></pre></td></tr></table></figure>
<h1 id="自定义损失函数（optional-取决于任务）"><a href="#自定义损失函数（optional-取决于任务）" class="headerlink" title="自定义损失函数（optional,取决于任务）"></a>自定义损失函数（optional,取决于任务）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_fn</span><span class="params">(start_logits, end_logits, start_positions, end_positions)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the sum of the cross entropy losses for both the start and end logits</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    loss_fct = nn.CrossEntropyLoss()</span><br><span class="line">    start_loss = loss_fct(start_logits, start_positions)</span><br><span class="line">    end_loss = loss_fct(end_logits, end_positions)</span><br><span class="line">    total_loss = (start_loss + end_loss)</span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br></pre></td></tr></table></figure>
<h1 id="Training-Function"><a href="#Training-Function" class="headerlink" title="Training Function"></a>Training Function</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_fn</span><span class="params">(data_loader, model, optimizer, device, scheduler=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Trains the bert model on the twitter data</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Set model to training mode (dropout + sampled batchnorm is activated)</span></span><br><span class="line">    model.train()</span><br><span class="line">    losses = utils.AverageMeter()</span><br><span class="line">    jaccards = utils.AverageMeter()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set tqdm to add loading screen and set the length</span></span><br><span class="line">    tk0 = tqdm(data_loader, total=len(data_loader))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Train the model on each batch</span></span><br><span class="line">    <span class="keyword">for</span> bi, d <span class="keyword">in</span> enumerate(tk0):</span><br><span class="line"></span><br><span class="line">        ids = d[<span class="string">"ids"</span>]</span><br><span class="line">        token_type_ids = d[<span class="string">"token_type_ids"</span>]</span><br><span class="line">        mask = d[<span class="string">"mask"</span>]</span><br><span class="line">        targets_start = d[<span class="string">"targets_start"</span>]</span><br><span class="line">        targets_end = d[<span class="string">"targets_end"</span>]</span><br><span class="line">        sentiment = d[<span class="string">"sentiment"</span>]</span><br><span class="line">        orig_selected = d[<span class="string">"orig_selected"</span>]</span><br><span class="line">        orig_tweet = d[<span class="string">"orig_tweet"</span>]</span><br><span class="line">        targets_start = d[<span class="string">"targets_start"</span>]</span><br><span class="line">        targets_end = d[<span class="string">"targets_end"</span>]</span><br><span class="line">        offsets = d[<span class="string">"offsets"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Move ids, masks, and targets to gpu while setting as torch.long</span></span><br><span class="line">        ids = ids.to(device, dtype=torch.long)</span><br><span class="line">        token_type_ids = token_type_ids.to(device, dtype=torch.long)</span><br><span class="line">        mask = mask.to(device, dtype=torch.long)</span><br><span class="line">        targets_start = targets_start.to(device, dtype=torch.long)</span><br><span class="line">        targets_end = targets_end.to(device, dtype=torch.long)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reset gradients</span></span><br><span class="line">        model.zero_grad()</span><br><span class="line">        <span class="comment"># Use ids, masks, and token types as input to the model</span></span><br><span class="line">        <span class="comment"># Predict logits for each of the input tokens for each batch</span></span><br><span class="line">        outputs_start, outputs_end = model(</span><br><span class="line">            ids=ids,</span><br><span class="line">            mask=mask,</span><br><span class="line">            token_type_ids=token_type_ids,</span><br><span class="line">        ) <span class="comment"># (bs x SL), (bs x SL)</span></span><br><span class="line">        <span class="comment"># Calculate batch loss based on CrossEntropy</span></span><br><span class="line">        loss = loss_fn(outputs_start, outputs_end, targets_start, targets_end)</span><br><span class="line">        <span class="comment"># Calculate gradients based on loss</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># Adjust weights based on calculated gradients</span></span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment"># Update scheduler</span></span><br><span class="line">        scheduler.step()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Apply softmax to the start and end logits</span></span><br><span class="line">        <span class="comment"># This squeezes each of the logits in a sequence to a value between 0 and 1, while ensuring that they sum to 1</span></span><br><span class="line">        <span class="comment"># This is similar to the characteristics of "probabilities"</span></span><br><span class="line">        outputs_start = torch.softmax(outputs_start, dim=<span class="number">1</span>).cpu().detach().numpy()</span><br><span class="line">        outputs_end = torch.softmax(outputs_end, dim=<span class="number">1</span>).cpu().detach().numpy()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate the jaccard score based on the predictions for this batch</span></span><br><span class="line">        jaccard_scores = []</span><br><span class="line">        <span class="keyword">for</span> px, tweet <span class="keyword">in</span> enumerate(orig_tweet):</span><br><span class="line">            selected_tweet = orig_selected[px]</span><br><span class="line">            tweet_sentiment = sentiment[px]</span><br><span class="line">            jaccard_score, _ = calculate_jaccard_score(</span><br><span class="line">                original_tweet=tweet, <span class="comment"># Full text of the px'th tweet in the batch</span></span><br><span class="line">                target_string=selected_tweet, <span class="comment"># Span containing the specified sentiment for the px'th tweet in the batch</span></span><br><span class="line">                sentiment_val=tweet_sentiment, <span class="comment"># Sentiment of the px'th tweet in the batch</span></span><br><span class="line">                idx_start=np.argmax(outputs_start[px, :]), <span class="comment"># Predicted start index for the px'th tweet in the batch</span></span><br><span class="line">                idx_end=np.argmax(outputs_end[px, :]), <span class="comment"># Predicted end index for the px'th tweet in the batch</span></span><br><span class="line">                offsets=offsets[px] <span class="comment"># Offsets for each of the tokens for the px'th tweet in the batch</span></span><br><span class="line">            )</span><br><span class="line">            jaccard_scores.append(jaccard_score)</span><br><span class="line">        <span class="comment"># Update the jaccard score and loss</span></span><br><span class="line">        <span class="comment"># For details, refer to `AverageMeter` in https://www.kaggle.com/abhishek/utils</span></span><br><span class="line">        jaccards.update(np.mean(jaccard_scores), ids.size(<span class="number">0</span>))</span><br><span class="line">        losses.update(loss.item(), ids.size(<span class="number">0</span>))</span><br><span class="line">        <span class="comment"># Print the average loss and jaccard score at the end of each batch</span></span><br><span class="line">        tk0.set_postfix(loss=losses.avg, jaccard=jaccards.avg)</span><br></pre></td></tr></table></figure>
<h1 id="Evaluation-Functions"><a href="#Evaluation-Functions" class="headerlink" title="Evaluation Functions"></a>Evaluation Functions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_jaccard_score</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    original_tweet, </span></span></span><br><span class="line"><span class="function"><span class="params">    target_string, </span></span></span><br><span class="line"><span class="function"><span class="params">    sentiment_val, </span></span></span><br><span class="line"><span class="function"><span class="params">    idx_start, </span></span></span><br><span class="line"><span class="function"><span class="params">    idx_end, </span></span></span><br><span class="line"><span class="function"><span class="params">    offsets,</span></span></span><br><span class="line"><span class="function"><span class="params">    verbose=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculate the jaccard score from the predicted span and the actual span for a batch of tweets</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># A span's start index has to be greater than or equal to the end index</span></span><br><span class="line">    <span class="comment"># If this doesn't hold, the start index is set to equal the end index (the span is a single token)</span></span><br><span class="line">    <span class="keyword">if</span> idx_end &lt; idx_start:</span><br><span class="line">        idx_end = idx_start</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Combine into a string the tokens that belong to the predicted span</span></span><br><span class="line">    filtered_output  = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> ix <span class="keyword">in</span> range(idx_start, idx_end + <span class="number">1</span>):</span><br><span class="line">        filtered_output += original_tweet[offsets[ix][<span class="number">0</span>]: offsets[ix][<span class="number">1</span>]]</span><br><span class="line">        <span class="comment"># If the token is not the last token in the tweet, and the ending offset of the current token is less</span></span><br><span class="line">        <span class="comment"># than the beginning offset of the following token, add a space.</span></span><br><span class="line">        <span class="comment"># Basically, add a space when the next token (word piece) corresponds to a new word</span></span><br><span class="line">        <span class="keyword">if</span> (ix+<span class="number">1</span>) &lt; len(offsets) <span class="keyword">and</span> offsets[ix][<span class="number">1</span>] &lt; offsets[ix+<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">            filtered_output += <span class="string">" "</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the predicted output as the original tweet when the tweet's sentiment is "neutral", or the tweet only contains one word</span></span><br><span class="line">    <span class="keyword">if</span> sentiment_val == <span class="string">"neutral"</span> <span class="keyword">or</span> len(original_tweet.split()) &lt; <span class="number">2</span>:</span><br><span class="line">        filtered_output = original_tweet</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate the jaccard score between the predicted span, and the actual span</span></span><br><span class="line">    <span class="comment"># The IOU (intersection over union) approach is detailed in the utils module's `jaccard` function:</span></span><br><span class="line">    <span class="comment"># https://www.kaggle.com/abhishek/utils</span></span><br><span class="line">    jac = utils.jaccard(target_string.strip(), filtered_output.strip())</span><br><span class="line">    <span class="keyword">return</span> jac, filtered_output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_fn</span><span class="params">(data_loader, model, device)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Evaluation function to predict on the test set</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Set model to evaluation mode</span></span><br><span class="line">    <span class="comment"># I.e., turn off dropout and set batchnorm to use overall mean and variance (from training), rather than batch level mean and variance</span></span><br><span class="line">    <span class="comment"># Reference: https://github.com/pytorch/pytorch/issues/5406</span></span><br><span class="line">    model.eval()</span><br><span class="line">    losses = utils.AverageMeter()</span><br><span class="line">    jaccards = utils.AverageMeter()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Turns off gradient calculations (https://datascience.stackexchange.com/questions/32651/what-is-the-use-of-torch-no-grad-in-pytorch)</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        tk0 = tqdm(data_loader, total=len(data_loader))</span><br><span class="line">        <span class="comment"># Make predictions and calculate loss / jaccard score for each batch</span></span><br><span class="line">        <span class="keyword">for</span> bi, d <span class="keyword">in</span> enumerate(tk0):</span><br><span class="line">            ids = d[<span class="string">"ids"</span>]</span><br><span class="line">            token_type_ids = d[<span class="string">"token_type_ids"</span>]</span><br><span class="line">            mask = d[<span class="string">"mask"</span>]</span><br><span class="line">            sentiment = d[<span class="string">"sentiment"</span>]</span><br><span class="line">            orig_selected = d[<span class="string">"orig_selected"</span>]</span><br><span class="line">            orig_tweet = d[<span class="string">"orig_tweet"</span>]</span><br><span class="line">            targets_start = d[<span class="string">"targets_start"</span>]</span><br><span class="line">            targets_end = d[<span class="string">"targets_end"</span>]</span><br><span class="line">            offsets = d[<span class="string">"offsets"</span>].numpy()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Move tensors to GPU for faster matrix calculations</span></span><br><span class="line">            ids = ids.to(device, dtype=torch.long)</span><br><span class="line">            token_type_ids = token_type_ids.to(device, dtype=torch.long)</span><br><span class="line">            mask = mask.to(device, dtype=torch.long)</span><br><span class="line">            targets_start = targets_start.to(device, dtype=torch.long)</span><br><span class="line">            targets_end = targets_end.to(device, dtype=torch.long)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Predict logits for start and end indexes</span></span><br><span class="line">            outputs_start, outputs_end = model(</span><br><span class="line">                ids=ids,</span><br><span class="line">                mask=mask,</span><br><span class="line">                token_type_ids=token_type_ids</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># Calculate loss for the batch</span></span><br><span class="line">            loss = loss_fn(outputs_start, outputs_end, targets_start, targets_end)</span><br><span class="line">            <span class="comment"># Apply softmax to the predicted logits for the start and end indexes</span></span><br><span class="line">            <span class="comment"># This converts the "logits" to "probability-like" scores</span></span><br><span class="line">            outputs_start = torch.softmax(outputs_start, dim=<span class="number">1</span>).cpu().detach().numpy()</span><br><span class="line">            outputs_end = torch.softmax(outputs_end, dim=<span class="number">1</span>).cpu().detach().numpy()</span><br><span class="line">            <span class="comment"># Calculate jaccard scores for each tweet in the batch</span></span><br><span class="line">            jaccard_scores = []</span><br><span class="line">            <span class="keyword">for</span> px, tweet <span class="keyword">in</span> enumerate(orig_tweet):</span><br><span class="line">                selected_tweet = orig_selected[px]</span><br><span class="line">                tweet_sentiment = sentiment[px]</span><br><span class="line">                jaccard_score, _ = calculate_jaccard_score(</span><br><span class="line">                    original_tweet=tweet,</span><br><span class="line">                    target_string=selected_tweet,</span><br><span class="line">                    sentiment_val=tweet_sentiment,</span><br><span class="line">                    idx_start=np.argmax(outputs_start[px, :]),</span><br><span class="line">                    idx_end=np.argmax(outputs_end[px, :]),</span><br><span class="line">                    offsets=offsets[px]</span><br><span class="line">                )</span><br><span class="line">                jaccard_scores.append(jaccard_score)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Update running jaccard score and loss</span></span><br><span class="line">            jaccards.update(np.mean(jaccard_scores), ids.size(<span class="number">0</span>))</span><br><span class="line">            losses.update(loss.item(), ids.size(<span class="number">0</span>))</span><br><span class="line">            <span class="comment"># Print the running average loss and jaccard score</span></span><br><span class="line">            tk0.set_postfix(loss=losses.avg, jaccard=jaccards.avg)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">f"Jaccard = <span class="subst">&#123;jaccards.avg&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> jaccards.avg</span><br></pre></td></tr></table></figure>
<h1 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(fold)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Train model for a speciied fold</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Read training csv</span></span><br><span class="line">    dfx = pd.read_csv(config.TRAINING_FILE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set train validation set split</span></span><br><span class="line">    df_train = dfx[dfx.kfold != fold].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">    df_valid = dfx[dfx.kfold == fold].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Instantiate TweetDataset with training data</span></span><br><span class="line">    train_dataset = TweetDataset(</span><br><span class="line">        tweet=df_train.text.values,</span><br><span class="line">        sentiment=df_train.sentiment.values,</span><br><span class="line">        selected_text=df_train.selected_text.values</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instantiate DataLoader with `train_dataset`</span></span><br><span class="line">    <span class="comment"># This is a generator that yields the dataset in batches</span></span><br><span class="line">    train_data_loader = torch.utils.data.DataLoader(</span><br><span class="line">        train_dataset,</span><br><span class="line">        batch_size=config.TRAIN_BATCH_SIZE,</span><br><span class="line">        num_workers=<span class="number">4</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instantiate TweetDataset with validation data</span></span><br><span class="line">    valid_dataset = TweetDataset(</span><br><span class="line">        tweet=df_valid.text.values,</span><br><span class="line">        sentiment=df_valid.sentiment.values,</span><br><span class="line">        selected_text=df_valid.selected_text.values</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instantiate DataLoader with `valid_dataset`</span></span><br><span class="line">    valid_data_loader = torch.utils.data.DataLoader(</span><br><span class="line">        valid_dataset,</span><br><span class="line">        batch_size=config.VALID_BATCH_SIZE,</span><br><span class="line">        num_workers=<span class="number">2</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set device as `cuda` (GPU)</span></span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span>)</span><br><span class="line">    <span class="comment"># Load pretrained BERT (bert-base-uncased)</span></span><br><span class="line">    model_config = transformers.RobertaConfig.from_pretrained(config.ROBERTA_PATH)</span><br><span class="line">    <span class="comment"># Output hidden states</span></span><br><span class="line">    <span class="comment"># This is important to set since we want to concatenate the hidden states from the last 2 BERT layers</span></span><br><span class="line">    model_config.output_hidden_states = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># Instantiate our model with `model_config`</span></span><br><span class="line">    model = TweetModel(conf=model_config)</span><br><span class="line">    <span class="comment"># Move the model to the GPU</span></span><br><span class="line">    model.to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate the number of training steps</span></span><br><span class="line">    num_train_steps = int(len(df_train) / config.TRAIN_BATCH_SIZE * config.EPOCHS)</span><br><span class="line">    <span class="comment"># Get the list of named parameters</span></span><br><span class="line">    param_optimizer = list(model.named_parameters())</span><br><span class="line">    <span class="comment"># Specify parameters where weight decay shouldn't be applied</span></span><br><span class="line">    no_decay = [<span class="string">"bias"</span>, <span class="string">"LayerNorm.bias"</span>, <span class="string">"LayerNorm.weight"</span>]</span><br><span class="line">    <span class="comment"># Define two sets of parameters: those with weight decay, and those without</span></span><br><span class="line">    optimizer_parameters = [</span><br><span class="line">        &#123;<span class="string">'params'</span>: [p <span class="keyword">for</span> n, p <span class="keyword">in</span> param_optimizer <span class="keyword">if</span> <span class="keyword">not</span> any(nd <span class="keyword">in</span> n <span class="keyword">for</span> nd <span class="keyword">in</span> no_decay)], <span class="string">'weight_decay'</span>: <span class="number">0.001</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'params'</span>: [p <span class="keyword">for</span> n, p <span class="keyword">in</span> param_optimizer <span class="keyword">if</span> any(nd <span class="keyword">in</span> n <span class="keyword">for</span> nd <span class="keyword">in</span> no_decay)], <span class="string">'weight_decay'</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># Instantiate AdamW optimizer with our two sets of parameters, and a learning rate of 3e-5</span></span><br><span class="line">    optimizer = AdamW(optimizer_parameters, lr=<span class="number">3e-5</span>)</span><br><span class="line">    <span class="comment"># Create a scheduler to set the learning rate at each training step</span></span><br><span class="line">    <span class="comment"># "Create a schedule with a learning rate that decreases linearly after linearly increasing during a warmup period." (https://pytorch.org/docs/stable/optim.html)</span></span><br><span class="line">    <span class="comment"># Since num_warmup_steps = 0, the learning rate starts at 3e-5, and then linearly decreases at each training step</span></span><br><span class="line">    scheduler = get_linear_schedule_with_warmup(</span><br><span class="line">        optimizer, </span><br><span class="line">        num_warmup_steps=<span class="number">0</span>, </span><br><span class="line">        num_training_steps=num_train_steps</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Apply early stopping with patience of 2</span></span><br><span class="line">    <span class="comment"># This means to stop training new epochs when 2 rounds have passed without any improvement</span></span><br><span class="line">    es = utils.EarlyStopping(patience=<span class="number">2</span>, mode=<span class="string">"max"</span>)</span><br><span class="line">    print(<span class="string">f"Training is Starting for fold=<span class="subst">&#123;fold&#125;</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># I'm training only for 3 epochs even though I specified 5!!!</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        train_fn(train_data_loader, model, optimizer, device, scheduler=scheduler)</span><br><span class="line">        jaccard = eval_fn(valid_data_loader, model, device)</span><br><span class="line">        print(<span class="string">f"Jaccard Score = <span class="subst">&#123;jaccard&#125;</span>"</span>)</span><br><span class="line">        es(jaccard, model, model_path=<span class="string">f"model_<span class="subst">&#123;fold&#125;</span>.bin"</span>)</span><br><span class="line">        <span class="keyword">if</span> es.early_stop:</span><br><span class="line">            print(<span class="string">"Early stopping"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(fold=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(fold=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(fold=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(fold=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(fold=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h1 id="Do-the-evaluation-on-test-data"><a href="#Do-the-evaluation-on-test-data" class="headerlink" title="Do the evaluation on test data"></a>Do the evaluation on test data</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_test = pd.read_csv(<span class="string">"../input/tweet-sentiment-extraction/test.csv"</span>)</span><br><span class="line">df_test.loc[:, <span class="string">"selected_text"</span>] = df_test.text.values</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_test</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }


    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>textID</th>
      <th>text</th>
      <th>sentiment</th>
      <th>selected_text</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>f87dea47db</td>
      <td>Last session of the day  http://twitpic.com/67ezh</td>
      <td>neutral</td>
      <td>Last session of the day  http://twitpic.com/67ezh</td>
    </tr>
    <tr>
      <th>1</th>
      <td>96d74cb729</td>
      <td>Shanghai is also really exciting (precisely -...</td>
      <td>positive</td>
      <td>Shanghai is also really exciting (precisely -...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>eee518ae67</td>
      <td>Recession hit Veronique Branquinho, she has to...</td>
      <td>negative</td>
      <td>Recession hit Veronique Branquinho, she has to...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>01082688c6</td>
      <td>happy bday!</td>
      <td>positive</td>
      <td>happy bday!</td>
    </tr>
    <tr>
      <th>4</th>
      <td>33987a8ee5</td>
      <td>http://twitpic.com/4w75p - I like it!!</td>
      <td>positive</td>
      <td>http://twitpic.com/4w75p - I like it!!</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>3529</th>
      <td>e5f0e6ef4b</td>
      <td>its at 3 am, im very tired but i can`t sleep  ...</td>
      <td>negative</td>
      <td>its at 3 am, im very tired but i can`t sleep  ...</td>
    </tr>
    <tr>
      <th>3530</th>
      <td>416863ce47</td>
      <td>All alone in this old house again.  Thanks for...</td>
      <td>positive</td>
      <td>All alone in this old house again.  Thanks for...</td>
    </tr>
    <tr>
      <th>3531</th>
      <td>6332da480c</td>
      <td>I know what you mean. My little dog is sinkin...</td>
      <td>negative</td>
      <td>I know what you mean. My little dog is sinkin...</td>
    </tr>
    <tr>
      <th>3532</th>
      <td>df1baec676</td>
      <td>_sutra what is your next youtube video gonna b...</td>
      <td>positive</td>
      <td>_sutra what is your next youtube video gonna b...</td>
    </tr>
    <tr>
      <th>3533</th>
      <td>469e15c5a8</td>
      <td>http://twitpic.com/4woj2 - omgssh  ang cute n...</td>
      <td>positive</td>
      <td>http://twitpic.com/4woj2 - omgssh  ang cute n...</td>
    </tr>
  </tbody>
</table>
<p>3534 rows × 4 columns</p>

</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">"cuda"</span>)</span><br><span class="line">model_config = transformers.RobertaConfig.from_pretrained(config.ROBERTA_PATH)</span><br><span class="line">model_config.output_hidden_states = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load each of the five trained models and move to GPU</span></span><br><span class="line">model1 = TweetModel(conf=model_config)</span><br><span class="line">model1.to(device)</span><br><span class="line">model1.load_state_dict(torch.load(<span class="string">"model_0.bin"</span>))</span><br><span class="line">model1.eval()</span><br><span class="line"></span><br><span class="line">model2 = TweetModel(conf=model_config)</span><br><span class="line">model2.to(device)</span><br><span class="line">model2.load_state_dict(torch.load(<span class="string">"model_1.bin"</span>))</span><br><span class="line">model2.eval()</span><br><span class="line"></span><br><span class="line">model3 = TweetModel(conf=model_config)</span><br><span class="line">model3.to(device)</span><br><span class="line">model3.load_state_dict(torch.load(<span class="string">"model_2.bin"</span>))</span><br><span class="line">model3.eval()</span><br><span class="line"></span><br><span class="line">model4 = TweetModel(conf=model_config)</span><br><span class="line">model4.to(device)</span><br><span class="line">model4.load_state_dict(torch.load(<span class="string">"model_3.bin"</span>))</span><br><span class="line">model4.eval()</span><br><span class="line"></span><br><span class="line">model5 = TweetModel(conf=model_config)</span><br><span class="line">model5.to(device)</span><br><span class="line">model5.load_state_dict(torch.load(<span class="string">"model_4.bin"</span>))</span><br><span class="line">model5.eval()</span><br></pre></td></tr></table></figure>
<pre><code>TweetModel(
  (roberta): RobertaModel(
    (embeddings): RobertaEmbeddings(
      (word_embeddings): Embedding(50265, 768, padding_idx=1)
      (position_embeddings): Embedding(514, 768, padding_idx=1)
      (token_type_embeddings): Embedding(1, 768)
      (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
      (dropout): Dropout(p=0.1, inplace=False)
    )
    (encoder): BertEncoder(
      (layer): ModuleList(
        (0): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (1): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (2): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (3): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (4): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (5): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (6): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (7): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (8): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (9): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (10): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
        (11): BertLayer(
          (attention): BertAttention(
            (self): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
            (output): BertSelfOutput(
              (dense): Linear(in_features=768, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
          (intermediate): BertIntermediate(
            (dense): Linear(in_features=768, out_features=3072, bias=True)
          )
          (output): BertOutput(
            (dense): Linear(in_features=3072, out_features=768, bias=True)
            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
            (dropout): Dropout(p=0.1, inplace=False)
          )
        )
      )
    )
    (pooler): BertPooler(
      (dense): Linear(in_features=768, out_features=768, bias=True)
      (activation): Tanh()
    )
  )
  (drop_out): Dropout(p=0.1, inplace=False)
  (l_1): Linear(in_features=1536, out_features=400, bias=True)
  (l0): Linear(in_features=400, out_features=2, bias=True)
)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">final_output = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate TweetDataset with the test data</span></span><br><span class="line">test_dataset = TweetDataset(</span><br><span class="line">        tweet=df_test.text.values,</span><br><span class="line">        sentiment=df_test.sentiment.values,</span><br><span class="line">        selected_text=df_test.selected_text.values</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate DataLoader with `test_dataset`</span></span><br><span class="line">data_loader = torch.utils.data.DataLoader(</span><br><span class="line">    test_dataset,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    batch_size=config.VALID_BATCH_SIZE,</span><br><span class="line">    num_workers=<span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn of gradient calculations</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    tk0 = tqdm(data_loader, total=len(data_loader))</span><br><span class="line">    <span class="comment"># Predict the span containing the sentiment for each batch</span></span><br><span class="line">    <span class="keyword">for</span> bi, d <span class="keyword">in</span> enumerate(tk0):</span><br><span class="line">        ids = d[<span class="string">"ids"</span>]</span><br><span class="line">        token_type_ids = d[<span class="string">"token_type_ids"</span>]</span><br><span class="line">        mask = d[<span class="string">"mask"</span>]</span><br><span class="line">        sentiment = d[<span class="string">"sentiment"</span>]</span><br><span class="line">        orig_selected = d[<span class="string">"orig_selected"</span>]</span><br><span class="line">        orig_tweet = d[<span class="string">"orig_tweet"</span>]</span><br><span class="line">        targets_start = d[<span class="string">"targets_start"</span>]</span><br><span class="line">        targets_end = d[<span class="string">"targets_end"</span>]</span><br><span class="line">        offsets = d[<span class="string">"offsets"</span>].numpy()</span><br><span class="line"></span><br><span class="line">        ids = ids.to(device, dtype=torch.long)</span><br><span class="line">        token_type_ids = token_type_ids.to(device, dtype=torch.long)</span><br><span class="line">        mask = mask.to(device, dtype=torch.long)</span><br><span class="line">        targets_start = targets_start.to(device, dtype=torch.long)</span><br><span class="line">        targets_end = targets_end.to(device, dtype=torch.long)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Predict start and end logits for each of the five models</span></span><br><span class="line">        outputs_start1, outputs_end1 = model1(</span><br><span class="line">            ids=ids,</span><br><span class="line">            mask=mask,</span><br><span class="line">            token_type_ids=token_type_ids</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        outputs_start2, outputs_end2 = model2(</span><br><span class="line">            ids=ids,</span><br><span class="line">            mask=mask,</span><br><span class="line">            token_type_ids=token_type_ids</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        outputs_start3, outputs_end3 = model3(</span><br><span class="line">            ids=ids,</span><br><span class="line">            mask=mask,</span><br><span class="line">            token_type_ids=token_type_ids</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        outputs_start4, outputs_end4 = model4(</span><br><span class="line">            ids=ids,</span><br><span class="line">            mask=mask,</span><br><span class="line">            token_type_ids=token_type_ids</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        outputs_start5, outputs_end5 = model5(</span><br><span class="line">            ids=ids,</span><br><span class="line">            mask=mask,</span><br><span class="line">            token_type_ids=token_type_ids</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Get the average start and end logits across the five models and use these as predictions</span></span><br><span class="line">        <span class="comment"># This is a form of "ensembling"</span></span><br><span class="line">        outputs_start = (</span><br><span class="line">            outputs_start1 </span><br><span class="line">            + outputs_start2 </span><br><span class="line">            + outputs_start3 </span><br><span class="line">            + outputs_start4 </span><br><span class="line">            + outputs_start5</span><br><span class="line">        ) / <span class="number">5</span></span><br><span class="line">        outputs_end = (</span><br><span class="line">            outputs_end1 </span><br><span class="line">            + outputs_end2 </span><br><span class="line">            + outputs_end3 </span><br><span class="line">            + outputs_end4 </span><br><span class="line">            + outputs_end5</span><br><span class="line">        ) / <span class="number">5</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Apply softmax to the predicted start and end logits</span></span><br><span class="line">        outputs_start = torch.softmax(outputs_start, dim=<span class="number">1</span>).cpu().detach().numpy()</span><br><span class="line">        outputs_end = torch.softmax(outputs_end, dim=<span class="number">1</span>).cpu().detach().numpy()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Convert the start and end scores to actual predicted spans (in string form)</span></span><br><span class="line">        <span class="keyword">for</span> px, tweet <span class="keyword">in</span> enumerate(orig_tweet):</span><br><span class="line">            selected_tweet = orig_selected[px]</span><br><span class="line">            tweet_sentiment = sentiment[px]</span><br><span class="line">            _, output_sentence = calculate_jaccard_score(</span><br><span class="line">                original_tweet=tweet,</span><br><span class="line">                target_string=selected_tweet,</span><br><span class="line">                sentiment_val=tweet_sentiment,</span><br><span class="line">                idx_start=np.argmax(outputs_start[px, :]),</span><br><span class="line">                idx_end=np.argmax(outputs_end[px, :]),</span><br><span class="line">                offsets=offsets[px]</span><br><span class="line">            )</span><br><span class="line">            final_output.append(output_sentence)</span><br></pre></td></tr></table></figure>
<pre><code>HBox(children=(FloatProgress(value=0.0, max=221.0), HTML(value=&#39;&#39;)))
</code></pre><p>​<br>​    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post-process trick:</span></span><br><span class="line"><span class="comment"># Note: This trick comes from: https://www.kaggle.com/c/tweet-sentiment-extraction/discussion/140942</span></span><br><span class="line"><span class="comment"># When the LB resets, this trick won't help</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_process</span><span class="params">(selected)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">" "</span>.join(set(selected.lower().split()))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sample = pd.read_csv(<span class="string">"../input/tweet-sentiment-extraction/sample_submission.csv"</span>)</span><br><span class="line">sample.loc[:, <span class="string">'selected_text'</span>] = final_output</span><br><span class="line">sample.selected_text = sample.selected_text.map(post_process)</span><br><span class="line">sample.to_csv(<span class="string">"submission.csv"</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sample.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }


    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>textID</th>
      <th>selected_text</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>f87dea47db</td>
      <td>http://twitpic.com/67ezh the of day session last</td>
    </tr>
    <tr>
      <th>1</th>
      <td>96d74cb729</td>
      <td>exciting</td>
    </tr>
    <tr>
      <th>2</th>
      <td>eee518ae67</td>
      <td>such shame! a</td>
    </tr>
    <tr>
      <th>3</th>
      <td>01082688c6</td>
      <td>happy bday!</td>
    </tr>
    <tr>
      <th>4</th>
      <td>33987a8ee5</td>
      <td>i like</td>
    </tr>
  </tbody>
</table>

</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">source_DF = inspect.getsource(utils)</span><br><span class="line">print(source_DF)</span><br></pre></td></tr></table></figure>
<pre><code>import numpy as np
import torch
</code></pre><p>​    </p>
<pre><code>class AverageMeter:
    &quot;&quot;&quot;
    Computes and stores the average and current value
    &quot;&quot;&quot;
    def __init__(self):
        self.reset()

    def reset(self):
        self.val = 0
        self.avg = 0
        self.sum = 0
        self.count = 0

    def update(self, val, n=1):
        self.val = val
        self.sum += val * n
        self.count += n
        self.avg = self.sum / self.count
</code></pre><p>​    </p>
<pre><code>class EarlyStopping:
    def __init__(self, patience=7, mode=&quot;max&quot;, delta=0.001):
        self.patience = patience
        self.counter = 0
        self.mode = mode
        self.best_score = None
        self.early_stop = False
        self.delta = delta
        if self.mode == &quot;min&quot;:
            self.val_score = np.Inf
        else:
            self.val_score = -np.Inf

    def __call__(self, epoch_score, model, model_path):

        if self.mode == &quot;min&quot;:
            score = -1.0 * epoch_score
        else:
            score = np.copy(epoch_score)

        if self.best_score is None:
            self.best_score = score
            self.save_checkpoint(epoch_score, model, model_path)
        elif score &lt; self.best_score + self.delta:
            self.counter += 1
            print(&#39;EarlyStopping counter: {} out of {}&#39;.format(self.counter, self.patience))
            if self.counter &gt;= self.patience:
                self.early_stop = True
        else:
            self.best_score = score
            self.save_checkpoint(epoch_score, model, model_path)
            self.counter = 0

    def save_checkpoint(self, epoch_score, model, model_path):
        if epoch_score not in [-np.inf, np.inf, -np.nan, np.nan]:
            print(&#39;Validation score improved ({} --&gt; {}). Saving model!&#39;.format(self.val_score, epoch_score))
            torch.save(model.state_dict(), model_path)
        self.val_score = epoch_score
</code></pre><p>​    </p>
<pre><code>def jaccard(str1, str2): 
    a = set(str1.lower().split()) 
    b = set(str2.lower().split())
    c = a.intersection(b)
    return float(len(c)) / (len(a) + len(b) - len(c))
</code></pre><p>​    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dxzmpk.github.io/2020/04/24/%E6%99%AE%E9%80%9A%E5%AD%A6%E7%94%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8Colab%E8%B7%91%E8%B5%B7%E6%9D%A5BERT%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="董雄">
      <meta itemprop="description" content="I am a fresh researcher in nlp in Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="董雄的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/%E6%99%AE%E9%80%9A%E5%AD%A6%E7%94%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8Colab%E8%B7%91%E8%B5%B7%E6%9D%A5BERT%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B%EF%BC%9F/" class="post-title-link" itemprop="url">普通学生，如何用Colab跑起来BERT系列模型？</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-24 23:04:11" itemprop="dateCreated datePublished" datetime="2020-04-24T23:04:11+08:00">2020-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-06 15:52:37" itemprop="dateModified" datetime="2020-05-06T15:52:37+08:00">2020-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nlp/" itemprop="url" rel="index"><span itemprop="name">nlp</span></a>
                </span>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="装载硬盘"><a href="#装载硬盘" class="headerlink" title="装载硬盘"></a>装载硬盘</h3><p><img src="/images/%E6%99%AE%E9%80%9A%E5%AD%A6%E7%94%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8Colab%E8%B7%91%E8%B5%B7%E6%9D%A5BERT%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B%EF%BC%9F/image-20200506150409157.png" alt="image-20200506150409157"></p>
<p>最终结果如图</p>
<p>然后通过右键点击数据文件，选择复制路径</p>
<p><img src="/images/%E6%99%AE%E9%80%9A%E5%AD%A6%E7%94%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8Colab%E8%B7%91%E8%B5%B7%E6%9D%A5BERT%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B%EF%BC%9F/image-20200506150608446.png" alt="image-20200506150608446"></p>
<p>这里数据路径为：<code>/content/drive/My Drive/Colab Notebooks/摘要-情感类型.xlsx</code></p>
<h3 id="启动GPU加速"><a href="#启动GPU加速" class="headerlink" title="启动GPU加速"></a>启动GPU加速</h3><p><img src="/images/%E6%99%AE%E9%80%9A%E5%AD%A6%E7%94%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8Colab%E8%B7%91%E8%B5%B7%E6%9D%A5BERT%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B%EF%BC%9F/image-20200506150505969.png" alt="image-20200506150505969"></p>
<p>如图，点击笔记本设置，选择gpu，确定，等待笔记本重启即可。</p>
<h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><p>可以逐行运行或者点击</p>
<p><img src="/images/%E6%99%AE%E9%80%9A%E5%AD%A6%E7%94%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8Colab%E8%B7%91%E8%B5%B7%E6%9D%A5BERT%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B%EF%BC%9F/image-20200506150715229.png" alt="image-20200506150715229"></p>
<p>全部运行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">董雄</p>
  <div class="site-description" itemprop="description">I am a fresh researcher in nlp in Harbin Institute of Technology</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董雄</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1278837449&web_id=1278837449"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 't8n8RTilca5Gm0vKToaMrjRU-gzGzoHsz',
      appKey     : 'x4Jty8MrDpczjPANtbbGhwXX',
      placeholder: "请留下一点痕迹吧, 评论将永远留存",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
